import {
  Delaunay
} from "./chunk-XTWSGURO.js";
import {
  band,
  color,
  cubehelix,
  cubehelixLong,
  diverging,
  divergingLog,
  divergingPow,
  divergingSymlog,
  format,
  hcl_default,
  hsl_default,
  identity,
  implicit,
  interpolateTransformCss,
  interpolateTransformSvg,
  lab,
  linear,
  log,
  number_default,
  ordinal,
  piecewise,
  point,
  pow,
  quantile as quantile2,
  quantize_default,
  rgb,
  rgbBasis,
  rgb_default,
  round_default,
  string_default,
  symlog,
  threshold,
  time,
  utcFormat,
  utcTickInterval,
  utcTime
} from "./chunk-BJZV432F.js";
import {
  Adder,
  InternMap,
  InternSet,
  ascending,
  bin,
  blur2,
  count,
  cross,
  cumsum,
  descending,
  deviation,
  difference,
  extent,
  greatest,
  group,
  groupSort,
  groups,
  least,
  max,
  maxIndex,
  mean,
  median,
  merge,
  min,
  minIndex,
  mode,
  pairs,
  quantile,
  range,
  rank,
  reverse,
  rollup,
  sort,
  sum,
  thresholdFreedmanDiaconis,
  thresholdScott,
  thresholdSturges,
  tickStep,
  ticks,
  variance
} from "./chunk-P7KS3E37.js";
import {
  area_default,
  asterisk_default,
  basisClosed_default,
  basisOpen_default,
  basis_default,
  bumpX,
  bumpY,
  bundle_default,
  cardinalClosed_default,
  cardinalOpen_default,
  cardinal_default,
  catmullRomClosed_default,
  catmullRomOpen_default,
  catmullRom_default,
  circle_default,
  cross_default,
  diamond2_default,
  diamond_default,
  line_default,
  linearClosed_default,
  linear_default,
  monotoneX,
  monotoneY,
  natural_default,
  path_default,
  plus_default,
  square2_default,
  square_default,
  star_default,
  stepAfter,
  stepBefore,
  step_default,
  symbolsFill,
  symbolsStroke,
  triangle2_default,
  triangle_default,
  wye_default,
  x_default
} from "./chunk-ZI7BMQM3.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HUBM7RA2.js";

// node_modules/binary-search-bounds/search-bounds.js
var require_search_bounds = __commonJS({
  "node_modules/binary-search-bounds/search-bounds.js"(exports, module) {
    "use strict";
    function ge(a, y2, c3, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a[m];
        var p = c3 !== void 0 ? c3(x2, y2) : x2 - y2;
        if (p >= 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function gt(a, y2, c3, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a[m];
        var p = c3 !== void 0 ? c3(x2, y2) : x2 - y2;
        if (p > 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function lt(a, y2, c3, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a[m];
        var p = c3 !== void 0 ? c3(x2, y2) : x2 - y2;
        if (p < 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function le(a, y2, c3, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a[m];
        var p = c3 !== void 0 ? c3(x2, y2) : x2 - y2;
        if (p <= 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function eq(a, y2, c3, l, h) {
      while (l <= h) {
        var m = l + h >>> 1, x2 = a[m];
        var p = c3 !== void 0 ? c3(x2, y2) : x2 - y2;
        if (p === 0) {
          return m;
        }
        if (p <= 0) {
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return -1;
    }
    function norm(a, y2, c3, l, h, f) {
      if (typeof c3 === "function") {
        return f(a, y2, c3, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0);
      }
      return f(a, y2, void 0, c3 === void 0 ? 0 : c3 | 0, l === void 0 ? a.length - 1 : l | 0);
    }
    module.exports = {
      ge: function(a, y2, c3, l, h) {
        return norm(a, y2, c3, l, h, ge);
      },
      gt: function(a, y2, c3, l, h) {
        return norm(a, y2, c3, l, h, gt);
      },
      lt: function(a, y2, c3, l, h) {
        return norm(a, y2, c3, l, h, lt);
      },
      le: function(a, y2, c3, l, h) {
        return norm(a, y2, c3, l, h, le);
      },
      eq: function(a, y2, c3, l, h) {
        return norm(a, y2, c3, l, h, eq);
      }
    };
  }
});

// node_modules/interval-tree-1d/interval-tree.js
var require_interval_tree = __commonJS({
  "node_modules/interval-tree-1d/interval-tree.js"(exports, module) {
    "use strict";
    var bounds = require_search_bounds();
    var NOT_FOUND = 0;
    var SUCCESS = 1;
    var EMPTY = 2;
    module.exports = createWrapper;
    function IntervalTreeNode(mid3, left2, right2, leftPoints, rightPoints) {
      this.mid = mid3;
      this.left = left2;
      this.right = right2;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.count = (left2 ? left2.count : 0) + (right2 ? right2.count : 0) + leftPoints.length;
    }
    var proto = IntervalTreeNode.prototype;
    function copy(a, b) {
      a.mid = b.mid;
      a.left = b.left;
      a.right = b.right;
      a.leftPoints = b.leftPoints;
      a.rightPoints = b.rightPoints;
      a.count = b.count;
    }
    function rebuild(node, intervals) {
      var ntree = createIntervalTree(intervals);
      node.mid = ntree.mid;
      node.left = ntree.left;
      node.right = ntree.right;
      node.leftPoints = ntree.leftPoints;
      node.rightPoints = ntree.rightPoints;
      node.count = ntree.count;
    }
    function rebuildWithInterval(node, interval2) {
      var intervals = node.intervals([]);
      intervals.push(interval2);
      rebuild(node, intervals);
    }
    function rebuildWithoutInterval(node, interval2) {
      var intervals = node.intervals([]);
      var idx = intervals.indexOf(interval2);
      if (idx < 0) {
        return NOT_FOUND;
      }
      intervals.splice(idx, 1);
      rebuild(node, intervals);
      return SUCCESS;
    }
    proto.intervals = function(result) {
      result.push.apply(result, this.leftPoints);
      if (this.left) {
        this.left.intervals(result);
      }
      if (this.right) {
        this.right.intervals(result);
      }
      return result;
    };
    proto.insert = function(interval2) {
      var weight = this.count - this.leftPoints.length;
      this.count += 1;
      if (interval2[1] < this.mid) {
        if (this.left) {
          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval2);
          } else {
            this.left.insert(interval2);
          }
        } else {
          this.left = createIntervalTree([interval2]);
        }
      } else if (interval2[0] > this.mid) {
        if (this.right) {
          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval2);
          } else {
            this.right.insert(interval2);
          }
        } else {
          this.right = createIntervalTree([interval2]);
        }
      } else {
        var l = bounds.ge(this.leftPoints, interval2, compareBegin);
        var r = bounds.ge(this.rightPoints, interval2, compareEnd);
        this.leftPoints.splice(l, 0, interval2);
        this.rightPoints.splice(r, 0, interval2);
      }
    };
    proto.remove = function(interval2) {
      var weight = this.count - this.leftPoints;
      if (interval2[1] < this.mid) {
        if (!this.left) {
          return NOT_FOUND;
        }
        var rw = this.right ? this.right.count : 0;
        if (4 * rw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval2);
        }
        var r = this.left.remove(interval2);
        if (r === EMPTY) {
          this.left = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else if (interval2[0] > this.mid) {
        if (!this.right) {
          return NOT_FOUND;
        }
        var lw = this.left ? this.left.count : 0;
        if (4 * lw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval2);
        }
        var r = this.right.remove(interval2);
        if (r === EMPTY) {
          this.right = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else {
        if (this.count === 1) {
          if (this.leftPoints[0] === interval2) {
            return EMPTY;
          } else {
            return NOT_FOUND;
          }
        }
        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {
          if (this.left && this.right) {
            var p = this;
            var n = this.left;
            while (n.right) {
              p = n;
              n = n.right;
            }
            if (p === this) {
              n.right = this.right;
            } else {
              var l = this.left;
              var r = this.right;
              p.count -= n.count;
              p.right = n.left;
              n.left = l;
              n.right = r;
            }
            copy(this, n);
            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
          } else if (this.left) {
            copy(this, this.left);
          } else {
            copy(this, this.right);
          }
          return SUCCESS;
        }
        for (var l = bounds.ge(this.leftPoints, interval2, compareBegin); l < this.leftPoints.length; ++l) {
          if (this.leftPoints[l][0] !== interval2[0]) {
            break;
          }
          if (this.leftPoints[l] === interval2) {
            this.count -= 1;
            this.leftPoints.splice(l, 1);
            for (var r = bounds.ge(this.rightPoints, interval2, compareEnd); r < this.rightPoints.length; ++r) {
              if (this.rightPoints[r][1] !== interval2[1]) {
                break;
              } else if (this.rightPoints[r] === interval2) {
                this.rightPoints.splice(r, 1);
                return SUCCESS;
              }
            }
          }
        }
        return NOT_FOUND;
      }
    };
    function reportLeftRange(arr, hi, cb) {
      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRightRange(arr, lo, cb) {
      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRange(arr, cb) {
      for (var i = 0; i < arr.length; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    proto.queryPoint = function(x2, cb) {
      if (x2 < this.mid) {
        if (this.left) {
          var r = this.left.queryPoint(x2, cb);
          if (r) {
            return r;
          }
        }
        return reportLeftRange(this.leftPoints, x2, cb);
      } else if (x2 > this.mid) {
        if (this.right) {
          var r = this.right.queryPoint(x2, cb);
          if (r) {
            return r;
          }
        }
        return reportRightRange(this.rightPoints, x2, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    proto.queryInterval = function(lo, hi, cb) {
      if (lo < this.mid && this.left) {
        var r = this.left.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi > this.mid && this.right) {
        var r = this.right.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi < this.mid) {
        return reportLeftRange(this.leftPoints, hi, cb);
      } else if (lo > this.mid) {
        return reportRightRange(this.rightPoints, lo, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    function compareNumbers(a, b) {
      return a - b;
    }
    function compareBegin(a, b) {
      var d = a[0] - b[0];
      if (d) {
        return d;
      }
      return a[1] - b[1];
    }
    function compareEnd(a, b) {
      var d = a[1] - b[1];
      if (d) {
        return d;
      }
      return a[0] - b[0];
    }
    function createIntervalTree(intervals) {
      if (intervals.length === 0) {
        return null;
      }
      var pts = [];
      for (var i = 0; i < intervals.length; ++i) {
        pts.push(intervals[i][0], intervals[i][1]);
      }
      pts.sort(compareNumbers);
      var mid3 = pts[pts.length >> 1];
      var leftIntervals = [];
      var rightIntervals = [];
      var centerIntervals = [];
      for (var i = 0; i < intervals.length; ++i) {
        var s = intervals[i];
        if (s[1] < mid3) {
          leftIntervals.push(s);
        } else if (mid3 < s[0]) {
          rightIntervals.push(s);
        } else {
          centerIntervals.push(s);
        }
      }
      var leftPoints = centerIntervals;
      var rightPoints = centerIntervals.slice();
      leftPoints.sort(compareBegin);
      rightPoints.sort(compareEnd);
      return new IntervalTreeNode(
        mid3,
        createIntervalTree(leftIntervals),
        createIntervalTree(rightIntervals),
        leftPoints,
        rightPoints
      );
    }
    function IntervalTree2(root2) {
      this.root = root2;
    }
    var tproto = IntervalTree2.prototype;
    tproto.insert = function(interval2) {
      if (this.root) {
        this.root.insert(interval2);
      } else {
        this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);
      }
    };
    tproto.remove = function(interval2) {
      if (this.root) {
        var r = this.root.remove(interval2);
        if (r === EMPTY) {
          this.root = null;
        }
        return r !== NOT_FOUND;
      }
      return false;
    };
    tproto.queryPoint = function(p, cb) {
      if (this.root) {
        return this.root.queryPoint(p, cb);
      }
    };
    tproto.queryInterval = function(lo, hi, cb) {
      if (lo <= hi && this.root) {
        return this.root.queryInterval(lo, hi, cb);
      }
    };
    Object.defineProperty(tproto, "count", {
      get: function() {
        if (this.root) {
          return this.root.count;
        }
        return 0;
      }
    });
    Object.defineProperty(tproto, "intervals", {
      get: function() {
        if (this.root) {
          return this.root.intervals([]);
        }
        return [];
      }
    });
    function createWrapper(intervals) {
      if (!intervals || intervals.length === 0) {
        return new IntervalTree2(null);
      }
      return new IntervalTree2(createIntervalTree(intervals));
    }
  }
});

// node_modules/d3-axis/src/identity.js
function identity_default(x2) {
  return x2;
}

// node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x2) {
  return "translate(" + x2 + ",0)";
}
function translateY(y2) {
  return "translate(0," + y2 + ")";
}
function number(scale2) {
  return (d) => +scale2(d);
}
function center(scale2, offset2) {
  offset2 = Math.max(0, scale2.bandwidth() - offset2 * 2) / 2;
  if (scale2.round())
    offset2 = Math.round(offset2);
  return (d) => +scale2(d) + offset2;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale2) {
  var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values2 = tickValues == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues, format3 = tickFormat == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity_default : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale2.range(), range0 = +range3[0] + offset2, range1 = +range3[range3.length - 1] + offset2, position2 = (scale2.bandwidth ? center : number)(scale2.copy(), offset2), selection2 = context.selection ? context.selection() : context, path = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale2).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path = path.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position2(d)) ? transform2(d + offset2) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset2);
      });
    }
    tickExit.remove();
    path.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position2(d) + offset2);
    });
    line2.attr(x2 + "2", k * tickSizeInner);
    text2.attr(x2, k * spacing).text(format3);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale2 = _, axis2) : scale2;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis2) : tickFormat;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset2 = +_, axis2) : offset2;
  };
  return axis2;
}
function axisTop(scale2) {
  return axis(top, scale2);
}
function axisRight(scale2) {
  return axis(right, scale2);
}
function axisBottom(scale2) {
  return axis(bottom, scale2);
}
function axisLeft(scale2) {
  return axis(left, scale2);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i = 0, n = type2.length, c3; i < n; ++i) {
    if ((c3 = type2[i]).name === name) {
      return c3.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select2) {
  if (typeof select2 !== "function")
    select2 = selector_default(select2);
  for (var groups2 = this._groups, m = groups2.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selectAll_default(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m = groups2.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group3));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m = groups2.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group3, enter, update, exit, data) {
  var i = 0, node, groupLength = group3.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group3[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group3[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group3, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group3[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group3) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group3[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m = groups2.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group3 = groups2[j], groupLength = group3.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j = -1, m = groups2.length; ++j < m; ) {
    for (var group3 = groups2[j], i = group3.length - 1, next = group3[i], node; --i >= 0; ) {
      if (node = group3[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups2 = this._groups, m = groups2.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j = 0, m = groups2.length; j < m; ++j) {
    for (var group3 = groups2[j], i = 0, n = group3.length; i < n; ++i) {
      var node = group3[i];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j = 0, m = groups2.length; j < m; ++j) {
    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {
      if (node = group3[i])
        callback.call(node, node.__data__, i, group3);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create3 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create3.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create3 = typeof name === "function" ? name : creator_default(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create3.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window3 = window_default(node), event = window3.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window3.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j = 0, m = groups2.length; j < m; ++j) {
    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {
      if (node = group3[i])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/create.js
function create_default(name) {
  return select_default2(creator_default(name).call(document.documentElement));
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node))
      if (!(node = node.parentNode))
        return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-drag/src/event.js
function DragEvent(type2, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x: x2,
  y: y2,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x2, enumerable: true, configurable: true },
    y: { value: y2, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time2 = Infinity;
  while (t1) {
    if (t1._call) {
      if (time2 > t1._time)
        time2 = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group3, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index,
    group: group3,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty2 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty2)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c3;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c3 = color(b)) ? (b = c3, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m = groups2.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector_default(select2);
  for (var groups2 = this._groups, m = groups2.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m = groups2.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        for (var children2 = select2.call(node, node.__data__, i, group3), child, inherit3 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id2, k, children2, inherit3);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m = groups2.length, j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        var inherit3 = get2(node, id0);
        schedule_default(node, name, id1, i, group3, {
          time: inherit3.time + inherit3.delay + inherit3.duration,
          delay: 0,
          duration: inherit3.duration,
          ease: inherit3.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;

// node_modules/d3-ease/src/math.js
function tpmt(x2) {
  return (Math.pow(2, -10 * x2) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m = groups2.length, j = 0; j < m; ++j) {
    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        schedule_default(node, name, id2, i, group3, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max: max2, min: min2 } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x2, e) {
    return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y2, e) {
    return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t) {
  return { type: t };
}

// node_modules/d3-chord/src/math.js
var pi2 = Math.PI;
var halfPi2 = pi2 / 2;
var tau2 = pi2 * 2;

// node_modules/d3-chord/src/array.js
var slice = Array.prototype.slice;

// node_modules/d3-contour/src/array.js
var array2 = Array.prototype;
var slice2 = array2.slice;

// node_modules/d3-contour/src/ascending.js
function ascending_default(a, b) {
  return a - b;
}

// node_modules/d3-contour/src/area.js
function area_default2(ring) {
  var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area2;
}

// node_modules/d3-contour/src/constant.js
var constant_default5 = (x2) => () => x2;

// node_modules/d3-contour/src/contains.js
function contains_default(ring, hole) {
  var i = -1, n = hole.length, c3;
  while (++i < n)
    if (c3 = ringContains(ring, hole[i]))
      return c3;
  return 0;
}
function ringContains(ring, point2) {
  var x2 = point2[0], y2 = point2[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi4 = ring[i], xi = pi4[0], yi = pi4[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi4, pj, point2))
      return 0;
    if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi)
      contains = -contains;
  }
  return contains;
}
function segmentContains(a, b, c3) {
  var i;
  return collinear(a, b, c3) && within(a[i = +(a[0] === b[0])], c3[i], b[i]);
}
function collinear(a, b, c3) {
  return (b[0] - a[0]) * (c3[1] - a[1]) === (c3[0] - a[0]) * (b[1] - a[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

// node_modules/d3-contour/src/noop.js
function noop_default() {
}

// node_modules/d3-contour/src/contours.js
var cases = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function contours_default() {
  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
  function contours(values2) {
    var tz = threshold2(values2);
    if (!Array.isArray(tz)) {
      const e = extent(values2), ts = tickStep(e[0], e[1], tz);
      tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
    } else {
      tz = tz.slice().sort(ascending_default);
    }
    return tz.map((value) => contour(values2, value));
  }
  function contour(values2, value) {
    var polygons = [], holes = [];
    isorings(values2, value, function(ring) {
      smooth(ring, values2, value);
      if (area_default2(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains_default((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value,
      coordinates: polygons
    };
  }
  function isorings(values2, value, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x2, y2, t0, t1, t2, t3;
    x2 = y2 = -1;
    t1 = values2[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x2 < dx - 1) {
      t0 = t1, t1 = values2[x2 + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);
    while (++y2 < dy - 1) {
      x2 = -1;
      t1 = values2[y2 * dx + dx] >= value;
      t2 = values2[y2 * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x2 < dx - 1) {
        t0 = t1, t1 = values2[y2 * dx + dx + x2 + 1] >= value;
        t3 = t2, t2 = values2[y2 * dx + x2 + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }
    x2 = -1;
    t2 = values2[y2 * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x2 < dx - 1) {
      t3 = t2, t2 = values2[y2 * dx + x2 + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);
    function stitch(line2) {
      var start2 = [line2[0][0] + x2, line2[0][1] + y2], end = [line2[1][0] + x2, line2[1][1] + y2], startIndex = index(start2), endIndex = index(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start2);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };
      }
    }
  }
  function index(point2) {
    return point2[0] * 2 + point2[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values2, value) {
    ring.forEach(function(point2) {
      var x2 = point2[0], y2 = point2[1], xt = x2 | 0, yt = y2 | 0, v0, v1 = values2[yt * dx + xt];
      if (x2 > 0 && x2 < dx && xt === x2) {
        v0 = values2[yt * dx + xt - 1];
        point2[0] = x2 + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y2 > 0 && y2 < dy && yt === y2) {
        v0 = values2[(yt - 1) * dx + xt];
        point2[1] = y2 + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours.contour = contour;
  contours.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };
  contours.thresholds = function(_) {
    return arguments.length ? (threshold2 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default5(slice2.call(_)) : constant_default5(_), contours) : threshold2;
  };
  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
  };
  return contours;
}

// node_modules/d3-contour/src/density.js
function defaultX(d) {
  return d[0];
}
function defaultY(d) {
  return d[1];
}
function defaultWeight() {
  return 1;
}
function density_default() {
  var x2 = defaultX, y2 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k = 2, o = r * 3, n = dx + o * 2 >> k, m = dy + o * 2 >> k, threshold2 = constant_default5(20);
  function grid(data) {
    var values2 = new Float32Array(n * m), pow2k = Math.pow(2, -k), i = -1;
    for (const d of data) {
      var xi = (x2(d, ++i, data) + o) * pow2k, yi = (y2(d, i, data) + o) * pow2k, wi = +weight(d, i, data);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        var x05 = Math.floor(xi), y05 = Math.floor(yi), xt = xi - x05 - 0.5, yt = yi - y05 - 0.5;
        values2[x05 + y05 * n] += (1 - xt) * (1 - yt) * wi;
        values2[x05 + 1 + y05 * n] += xt * (1 - yt) * wi;
        values2[x05 + 1 + (y05 + 1) * n] += xt * yt * wi;
        values2[x05 + (y05 + 1) * n] += (1 - xt) * yt * wi;
      }
    }
    blur2({ data: values2, width: n, height: m }, r * pow2k);
    return values2;
  }
  function density2(data) {
    var values2 = grid(data), tz = threshold2(values2), pow4k = Math.pow(2, 2 * k);
    if (!Array.isArray(tz)) {
      tz = ticks(Number.MIN_VALUE, max(values2) / pow4k, tz);
    }
    return contours_default().size([n, m]).thresholds(tz.map((d) => d * pow4k))(values2).map((c3, i) => (c3.value = +tz[i], transform2(c3)));
  }
  density2.contours = function(data) {
    var values2 = grid(data), contours = contours_default().size([n, m]), pow4k = Math.pow(2, 2 * k), contour = (value) => {
      value = +value;
      var c3 = transform2(contours.contour(values2, value * pow4k));
      c3.value = value;
      return c3;
    };
    Object.defineProperty(contour, "max", { get: () => max(values2) / pow4k });
    return contour;
  };
  function transform2(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }
  function resize() {
    o = r * 3;
    n = dx + o * 2 >> k;
    m = dy + o * 2 >> k;
    return density2;
  }
  density2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default5(+_), density2) : x2;
  };
  density2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default5(+_), density2) : y2;
  };
  density2.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : constant_default5(+_), density2) : weight;
  };
  density2.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };
  density2.cellSize = function(_) {
    if (!arguments.length)
      return 1 << k;
    if (!((_ = +_) >= 1))
      throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };
  density2.thresholds = function(_) {
    return arguments.length ? (threshold2 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default5(slice2.call(_)) : constant_default5(_), density2) : threshold2;
  };
  density2.bandwidth = function(_) {
    if (!arguments.length)
      return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0))
      throw new Error("invalid bandwidth");
    return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();
  };
  return density2;
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column2 in row) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad(value, width) {
  var s = value + "", length2 = s.length;
  return length2 < width ? new Array(width - length2 + 1).join(0) + s : s;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse2(text2, f) {
    var convert, columns, rows = parseRows(text2, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f) {
    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text2.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text2.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c3;
      if (text2.charCodeAt(j) === QUOTE) {
        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c3 = text2.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text2.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c3 = text2.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c3 !== DELIMITER)
          continue;
        return text2.slice(j, i);
      }
      return eof = true, text2.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column2) {
        return formatValue(row[column2]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse: parse2,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

// node_modules/d3-fetch/src/text.js
function responseText(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.text();
}
function text_default3(input, init2) {
  return fetch(input, init2).then(responseText);
}

// node_modules/d3-fetch/src/dsv.js
function dsvParse(parse2) {
  return function(input, init2, row) {
    if (arguments.length === 2 && typeof init2 === "function")
      row = init2, init2 = void 0;
    return text_default3(input, init2).then(function(response) {
      return parse2(response, row);
    });
  };
}
var csv2 = dsvParse(csvParse);
var tsv2 = dsvParse(tsvParse);

// node_modules/d3-fetch/src/xml.js
function parser(type2) {
  return (input, init2) => text_default3(input, init2).then((text2) => new DOMParser().parseFromString(text2, type2));
}
var xml_default = parser("application/xml");
var html = parser("text/html");
var svg = parser("image/svg+xml");

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
  return add(this.cover(x2, y2), x2, y2, d);
}
function add(tree2, x2, y2, d) {
  if (isNaN(x2) || isNaN(y2))
    return tree2;
  var parent, node = tree2._root, leaf = { data: d }, x05 = tree2._x0, y05 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j;
  if (!node)
    return tree2._root = leaf, tree2;
  while (node.length) {
    if (right2 = x2 >= (xm = (x05 + x12) / 2))
      x05 = xm;
    else
      x12 = xm;
    if (bottom2 = y2 >= (ym = (y05 + y12) / 2))
      y05 = ym;
    else
      y12 = ym;
    if (parent = node, !(node = node[i = bottom2 << 1 | right2]))
      return parent[i] = leaf, tree2;
  }
  xp = +tree2._x.call(null, node.data);
  yp = +tree2._y.call(null, node.data);
  if (x2 === xp && y2 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree2._root = leaf, tree2;
  do {
    parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);
    if (right2 = x2 >= (xm = (x05 + x12) / 2))
      x05 = xm;
    else
      x12 = xm;
    if (bottom2 = y2 >= (ym = (y05 + y12) / 2))
      y05 = ym;
    else
      y12 = ym;
  } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree2;
}
function addAll(data) {
  var d, i, n = data.length, x2, y2, xz = new Array(n), yz = new Array(n), x05 = Infinity, y05 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x2 = +this._x.call(null, d = data[i])) || isNaN(y2 = +this._y.call(null, d)))
      continue;
    xz[i] = x2;
    yz[i] = y2;
    if (x2 < x05)
      x05 = x2;
    if (x2 > x12)
      x12 = x2;
    if (y2 < y05)
      y05 = y2;
    if (y2 > y12)
      y12 = y2;
  }
  if (x05 > x12 || y05 > y12)
    return this;
  this.cover(x05, y05).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
    return this;
  var x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x05)) {
    x12 = (x05 = Math.floor(x2)) + 1;
    y12 = (y05 = Math.floor(y2)) + 1;
  } else {
    var z = x12 - x05 || 1, node = this._root, parent, i;
    while (x05 > x2 || x2 >= x12 || y05 > y2 || y2 >= y12) {
      i = (y2 < y05) << 1 | x2 < x05;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x05 + z, y12 = y05 + z;
          break;
        case 1:
          x05 = x12 - z, y12 = y05 + z;
          break;
        case 2:
          x12 = x05 + z, y05 = y12 - z;
          break;
        case 3:
          x05 = x12 - z, y05 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x05, y05, x12, y12) {
  this.node = node;
  this.x0 = x05;
  this.y0 = y05;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x2, y2, radius2) {
  var data, x05 = this._x0, y05 = this._y0, x12, y12, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x05, y05, x3, y3));
  if (radius2 == null)
    radius2 = Infinity;
  else {
    x05 = x2 - radius2, y05 = y2 - radius2;
    x3 = x2 + radius2, y3 = y2 + radius2;
    radius2 *= radius2;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (x22 = q.x1) < x05 || (y22 = q.y1) < y05)
      continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y12, x22, ym),
        new quad_default(node[0], x12, y12, xm, ym)
      );
      if (i = (y2 >= ym) << 1 | x2 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius2) {
        var d = Math.sqrt(radius2 = d2);
        x05 = x2 - d, y05 = y2 - d;
        x3 = x2 + d, y3 = y2 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default3(d) {
  if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1, x2, y2, xm, ym, right2, bottom2, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right2 = x2 >= (xm = (x05 + x12) / 2))
        x05 = xm;
      else
        x12 = xm;
      if (bottom2 = y2 >= (ym = (y05 + y12) / 2))
        y05 = ym;
      else
        y12 = ym;
      if (!(parent = node, node = node[i = bottom2 << 1 | right2]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i)
    this.remove(data[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x05, y05, x12, y12;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2])
        quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x05, y05, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x05, y05, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX2(d) {
  return d[0];
}
function x_default2(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY2(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x2, y2) {
  var tree2 = new Quadtree(x2 == null ? defaultX2 : x2, y2 == null ? defaultY2 : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree2 : tree2.addAll(nodes);
}
function Quadtree(x2, y2, x05, y05, x12, y12) {
  this._x = x2;
  this._y = y2;
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy;
  if (!node.length)
    return copy._root = leaf_copy(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default2;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default3;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default2;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default2;
treeProto.y = y_default;

// node_modules/d3-force/src/simulation.js
var initialAngle = Math.PI * (3 - Math.sqrt(5));

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi3 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs3 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos2 = Math.cos;
var exp = Math.exp;
var log2 = Math.log;
var sin2 = Math.sin;
var sign = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi3 : Math.acos(x2);
}
function asin(x2) {
  return x2 > 1 ? halfPi3 : x2 < -1 ? -halfPi3 : Math.asin(x2);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  return [abs3(lambda) > pi3 ? lambda + Math.round(-lambda / tau3) * tau3 : lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default2() {
  var lines = [], line2;
  return {
    point: function(x2, y2, m) {
      line2.push([x2, y2, m]);
    },
    lineStart: function() {
      lines.push(line2 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line2 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a, b) {
  return abs3(a[0] - b[0]) < epsilon3 && abs3(a[1] - b[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point2, points, other, entry) {
  this.x = point2;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p0 = segment[0], p1 = segment[n2], x2;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x2 = new Intersection(p0, segment, null, true));
    clip.push(x2.o = new Intersection(p0, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start2 = subject[0], points, point2;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i)
            stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i)
            stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array3) {
  if (!(n = array3.length))
    return;
  var n, i = 0, a = array3[0], b;
  while (++i < n) {
    a.n = b = array3[i];
    b.p = a;
    a = b;
  }
  a.n = b = array3[0];
  b.p = a;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point2) {
  return abs3(point2[0]) <= pi3 ? point2[0] : sign(point2[0]) * ((abs3(point2[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point2) {
  var lambda = longitude(point2), phi2 = point2[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle = 0, winding = 0;
  var sum2 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi3 + epsilon3;
  else if (sinPhi === -1)
    phi2 = -halfPi3 - epsilon3;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length))
      continue;
    var ring, m, point0 = ring[m - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi3, k = sinPhi0 * sinPhi1;
      sum2.add(atan2(k * sign2 * sin2(absDelta), cosPhi0 * cosPhi1 + k * cos2(absDelta)));
      angle += antimeridian ? delta + sign2 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon3 || angle < epsilon3 && sum2 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start2) {
  return function(sink) {
    var line2 = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point2;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line2.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line2.lineStart();
    }
    function lineEnd() {
      clip.point = point2;
      line2.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i)
            sink.point((point3 = segment[i])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi3 - epsilon3 : halfPi3 - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon3 : halfPi3 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi3]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs3(lambda1 - lambda0);
      if (abs3(delta - pi3) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi3 : -halfPi3);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs3(lambda0 - sign0) < epsilon3)
          lambda0 -= sign0 * epsilon3;
        if (abs3(lambda1 - sign1) < epsilon3)
          lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs3(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi3;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs3(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;

// node_modules/d3-geo/src/identity.js
var identity_default2 = (x2) => x2;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs3(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x2, y2) {
  areaStream2.point = areaPoint;
  x00 = x0 = x2, y00 = y0 = y2;
}
function areaPoint(x2, y2) {
  areaRingSum2.add(y0 * x2 - x0 * y2);
  x0 = x2, y0 = y2;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default3 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x02)
    x02 = x2;
  if (x2 > x1)
    x1 = x2;
  if (y2 < y02)
    y02 = y2;
  if (y2 > y1)
    y1 = y2;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x2, y2) {
  X0 += x2;
  Y0 += y2;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x2, y2) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x2, y03 = y2);
}
function centroidPointLine(x2, y2) {
  var dx = x2 - x03, dy = y2 - y03, z = sqrt(dx * dx + dy * dy);
  X1 += z * (x03 + x2) / 2;
  Y1 += z * (y03 + y2) / 2;
  Z1 += z;
  centroidPoint(x03 = x2, y03 = y2);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x2, y2) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x2, y002 = y03 = y2);
}
function centroidPointRing(x2, y2) {
  var dx = x2 - x03, dy = y2 - y03, z = sqrt(dx * dx + dy * dy);
  X1 += z * (x03 + x2) / 2;
  Y1 += z * (y03 + y2) / 2;
  Z1 += z;
  z = y03 * x2 - x03 * y2;
  X2 += z * (x03 + x2);
  Y2 += z * (y03 + y2);
  Z2 += z * 3;
  centroidPoint(x03 = x2, y03 = y2);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y2);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y2);
        this._context.arc(x2, y2, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum = new Adder();
    return length2;
  }
};
function lengthPointFirst(x2, y2) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x2, y003 = y04 = y2;
}
function lengthPoint(x2, y2) {
  x04 -= x2, y04 -= y2;
  lengthSum.add(sqrt(x04 * x04 + y04 * y04));
  x04 = x2, y04 = y2;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius)
      this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._string.push("Z");
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x2, ",", y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x2, ",", y2);
        break;
      }
      default: {
        if (this._circle == null)
          this._circle = circle(this._radius);
        this._string.push("M", x2, ",", y2, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle(radius2) {
  return "m0," + radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + -2 * radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + 2 * radius2 + "z";
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection2, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path.area = function(object) {
    stream_default(object, projectionStream(area_default3));
    return area_default3.result();
  };
  path.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity_default2) : (projection2 = _).stream, path) : projection2;
  };
  path.context = function(_) {
    if (!arguments.length)
      return context;
    contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path;
  };
  path.pointRadius = function(_) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };
  return path.projection(projection2).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer(methods) {
  return function(stream) {
    var s = new TransformStream();
    for (var key in methods)
      s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/resample.js
var cosMinDistance = cos2(30 * radians);

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x2, y2) {
    this.stream.point(x2 * radians, y2 * radians);
  }
});

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale2) {
  return function(x2, y2) {
    var cx = cos2(x2), cy = cos2(y2), k = scale2(cx * cy);
    if (k === Infinity)
      return [2, 0];
    return [
      k * cy * sin2(x2),
      k * sin2(y2)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x2, y2) {
    var z = sqrt(x2 * x2 + y2 * y2), c3 = angle(z), sc = sin2(c3), cc = cos2(c3);
    return [
      atan2(x2 * sc, z * cc),
      asin(z && y2 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c3) {
  return (c3 = acos(c3)) && c3 / sin2(c3);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log2(tan((halfPi3 + phi2) / 2))];
}
mercatorRaw.invert = function(x2, y2) {
  return [x2, 2 * atan(exp(y2)) - halfPi3];
};

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x2, y2) {
  var l = y2, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y2;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs3(delta) < epsilon22)
      break;
  }
  return [
    M * x2 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin(sin2(l) / M)
  ];
};

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x2, y2) {
  var cy = cos2(y2), k = cos2(x2) * cy;
  return [cy * sin2(x2) / k, sin2(y2) / k];
}
gnomonicRaw.invert = azimuthalInvert(atan);

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y2) {
  var phi2 = y2, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y2) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs3(delta) > epsilon3 && --i > 0);
  return [
    x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x2, y2) {
  return [cos2(y2) * sin2(x2), sin2(y2)];
}
orthographicRaw.invert = azimuthalInvert(asin);

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x2, y2) {
  var cy = cos2(y2), k = 1 + cos2(x2) * cy;
  return [cy * sin2(x2) / k, sin2(y2) / k];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log2(tan((halfPi3 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y2) {
  return [-y2, 2 * atan(exp(x2)) - halfPi3];
};

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x2, c3) {
  return x2 + c3.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c3) {
  return Math.max(y2, c3.y);
}
function leafLeft(node) {
  var children2;
  while (children2 = node.children)
    node = children2[0];
  return node;
}
function leafRight(node) {
  var children2;
  while (children2 = node.children)
    node = children2[children2.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster2(root2) {
    var previousNode, x2 = 0;
    root2.eachAfter(function(node) {
      var children2 = node.children;
      if (children2) {
        node.x = meanX(children2);
        node.y = maxY(children2);
      } else {
        node.x = previousNode ? x2 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x05) / (x12 - x05) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster2.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster2) : separation;
  };
  cluster2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? null : [dx, dy];
  };
  cluster2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? [dx, dy] : null;
  };
  return cluster2;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node) {
  var sum2 = 0, children2 = node.children, i = children2 && children2.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children2[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count2);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children2, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum2 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0)
      sum2 += children2[i].value;
    node.value = sum2;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default3(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b)
    return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c3 = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c3 = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c3;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children2, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0)
      children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node2(data), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default2,
  path: path_default3,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x12 - x05) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y05, node.y1 = y12;
    node.x0 = x05, node.x1 = x05 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id2 = defaultId, parentId = defaultParentId, path;
  function stratify(data) {
    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path != null) {
      const I = nodes.map((d2, i2) => normalize(path(d2, i2, data)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_, i2) => I[i2];
      currentParentId = (_, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node2(d);
      if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    if (path != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed)
          break;
        node.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x2) {
    return arguments.length ? (id2 = optional(x2), stratify) : id2;
  };
  stratify.parentId = function(x2) {
    return arguments.length ? (parentId = optional(x2), stratify) : parentId;
  };
  stratify.path = function(x2) {
    return arguments.length ? (path = optional(x2), stratify) : path;
  };
  return stratify;
}
function normalize(path) {
  path = `${path}`;
  let i = path.length;
  if (slash(path, i - 1) && !slash(path, i - 2))
    path = path.slice(0, -1);
  return path[0] === "/" ? path : `/${path}`;
}
function parentof(path) {
  let i = path.length;
  if (i < 2)
    return "";
  while (--i > 1)
    if (slash(path, i))
      break;
  return path.slice(0, i);
}
function slash(path, i) {
  if (path[i] === "/") {
    let k = 0;
    while (i > 0 && path[--i] === "\\")
      ++k;
    if ((k & 1) === 0)
      return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children2 = v.children;
  return children2 ? children2[0] : v.t;
}
function nextRight(v) {
  var children2 = v.children;
  return children2 ? children2[children2.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children2 = v.children, i = children2.length, w;
  while (--i >= 0) {
    w = children2[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node2.prototype);
function treeRoot(root2) {
  var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children2, i, n;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n = children2.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
        child.parent = node;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree2(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom2 = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom2.depth)
          bottom2 = node;
      });
      var s = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s - left2.x, kx = dx / (right2.x + s + tx), ky = dy / (bottom2.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children2 = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children2) {
      executeShifts(v);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree2.separation = function(x2) {
    return arguments.length ? (separation = x2, tree2) : separation;
  };
  tree2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
  };
  tree2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
  };
  return tree2;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y12 - y05) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x05, node.x1 = x12;
    node.y0 = y05, node.y1 = y05 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x05, y05, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x05, dy = y12 - y05;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x05, y05, x12, value ? y05 += dy * sumValue / value : y12);
    else
      slice_default(row, x05, y05, value ? x05 += dx * sumValue / value : x12, y12);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom10(ratio) {
  function squarify(parent, x05, y05, x12, y12) {
    squarifyRatio(ratio, parent, x05, y05, x12, y12);
  }
  squarify.ratio = function(x2) {
    return custom10((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom11(ratio) {
  function resquarify(parent, x05, y05, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;
      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x05, y05, x12, value ? y05 += (y12 - y05) * row.value / value : y12);
        else
          slice_default(row, x05, y05, value ? x05 += (x12 - x05) * row.value / value : x12, y12);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x05, y05, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x2) {
    return custom11((x2 = +x2) > 1 ? x2 : 1);
  };
  return resquarify;
}(phi);

// node_modules/d3-random/src/defaultSource.js
var defaultSource_default = Math.random;

// node_modules/d3-random/src/uniform.js
var uniform_default = function sourceRandomUniform(source) {
  function randomUniform(min3, max4) {
    min3 = min3 == null ? 0 : +min3;
    max4 = max4 == null ? 1 : +max4;
    if (arguments.length === 1)
      max4 = min3, min3 = 0;
    else
      max4 -= min3;
    return function() {
      return source() * max4 + min3;
    };
  }
  randomUniform.source = sourceRandomUniform;
  return randomUniform;
}(defaultSource_default);

// node_modules/d3-random/src/int.js
var int_default = function sourceRandomInt(source) {
  function randomInt(min3, max4) {
    if (arguments.length < 2)
      max4 = min3, min3 = 0;
    min3 = Math.floor(min3);
    max4 = Math.floor(max4) - min3;
    return function() {
      return Math.floor(source() * max4 + min3);
    };
  }
  randomInt.source = sourceRandomInt;
  return randomInt;
}(defaultSource_default);

// node_modules/d3-random/src/normal.js
var normal_default = function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x2, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y2;
      if (x2 != null)
        y2 = x2, x2 = null;
      else
        do {
          x2 = source() * 2 - 1;
          y2 = source() * 2 - 1;
          r = x2 * x2 + y2 * y2;
        } while (!r || r > 1);
      return mu + sigma * y2 * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
  randomNormal.source = sourceRandomNormal;
  return randomNormal;
}(defaultSource_default);

// node_modules/d3-random/src/logNormal.js
var logNormal_default = function sourceRandomLogNormal(source) {
  var N = normal_default.source(source);
  function randomLogNormal() {
    var randomNormal = N.apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }
  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
}(defaultSource_default);

// node_modules/d3-random/src/irwinHall.js
var irwinHall_default = function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    if ((n = +n) <= 0)
      return () => 0;
    return function() {
      for (var sum2 = 0, i = n; i > 1; --i)
        sum2 += source();
      return sum2 + i * source();
    };
  }
  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
}(defaultSource_default);

// node_modules/d3-random/src/bates.js
var bates_default = function sourceRandomBates(source) {
  var I = irwinHall_default.source(source);
  function randomBates(n) {
    if ((n = +n) === 0)
      return source;
    var randomIrwinHall = I(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }
  randomBates.source = sourceRandomBates;
  return randomBates;
}(defaultSource_default);

// node_modules/d3-random/src/exponential.js
var exponential_default = function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log1p(-source()) / lambda;
    };
  }
  randomExponential.source = sourceRandomExponential;
  return randomExponential;
}(defaultSource_default);

// node_modules/d3-random/src/pareto.js
var pareto_default = function sourceRandomPareto(source) {
  function randomPareto(alpha) {
    if ((alpha = +alpha) < 0)
      throw new RangeError("invalid alpha");
    alpha = 1 / -alpha;
    return function() {
      return Math.pow(1 - source(), alpha);
    };
  }
  randomPareto.source = sourceRandomPareto;
  return randomPareto;
}(defaultSource_default);

// node_modules/d3-random/src/bernoulli.js
var bernoulli_default = function sourceRandomBernoulli(source) {
  function randomBernoulli(p) {
    if ((p = +p) < 0 || p > 1)
      throw new RangeError("invalid p");
    return function() {
      return Math.floor(source() + p);
    };
  }
  randomBernoulli.source = sourceRandomBernoulli;
  return randomBernoulli;
}(defaultSource_default);

// node_modules/d3-random/src/geometric.js
var geometric_default = function sourceRandomGeometric(source) {
  function randomGeometric(p) {
    if ((p = +p) < 0 || p > 1)
      throw new RangeError("invalid p");
    if (p === 0)
      return () => Infinity;
    if (p === 1)
      return () => 1;
    p = Math.log1p(-p);
    return function() {
      return 1 + Math.floor(Math.log1p(-source()) / p);
    };
  }
  randomGeometric.source = sourceRandomGeometric;
  return randomGeometric;
}(defaultSource_default);

// node_modules/d3-random/src/gamma.js
var gamma_default = function sourceRandomGamma(source) {
  var randomNormal = normal_default.source(source)();
  function randomGamma(k, theta) {
    if ((k = +k) < 0)
      throw new RangeError("invalid k");
    if (k === 0)
      return () => 0;
    theta = theta == null ? 1 : +theta;
    if (k === 1)
      return () => -Math.log1p(-source()) * theta;
    var d = (k < 1 ? k + 1 : k) - 1 / 3, c3 = 1 / (3 * Math.sqrt(d)), multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
    return function() {
      do {
        do {
          var x2 = randomNormal(), v = 1 + c3 * x2;
        } while (v <= 0);
        v *= v * v;
        var u = 1 - source();
      } while (u >= 1 - 0.0331 * x2 * x2 * x2 * x2 && Math.log(u) >= 0.5 * x2 * x2 + d * (1 - v + Math.log(v)));
      return d * v * multiplier() * theta;
    };
  }
  randomGamma.source = sourceRandomGamma;
  return randomGamma;
}(defaultSource_default);

// node_modules/d3-random/src/beta.js
var beta_default = function sourceRandomBeta(source) {
  var G = gamma_default.source(source);
  function randomBeta(alpha, beta) {
    var X3 = G(alpha), Y3 = G(beta);
    return function() {
      var x2 = X3();
      return x2 === 0 ? 0 : x2 / (x2 + Y3());
    };
  }
  randomBeta.source = sourceRandomBeta;
  return randomBeta;
}(defaultSource_default);

// node_modules/d3-random/src/binomial.js
var binomial_default = function sourceRandomBinomial(source) {
  var G = geometric_default.source(source), B = beta_default.source(source);
  function randomBinomial(n, p) {
    n = +n;
    if ((p = +p) >= 1)
      return () => n;
    if (p <= 0)
      return () => 0;
    return function() {
      var acc = 0, nn = n, pp = p;
      while (nn * pp > 16 && nn * (1 - pp) > 16) {
        var i = Math.floor((nn + 1) * pp), y2 = B(i, nn - i + 1)();
        if (y2 <= pp) {
          acc += i;
          nn -= i;
          pp = (pp - y2) / (1 - y2);
        } else {
          nn = i - 1;
          pp /= y2;
        }
      }
      var sign2 = pp < 0.5, pFinal = sign2 ? pp : 1 - pp, g = G(pFinal);
      for (var s = g(), k = 0; s <= nn; ++k)
        s += g();
      return acc + (sign2 ? k : nn - k);
    };
  }
  randomBinomial.source = sourceRandomBinomial;
  return randomBinomial;
}(defaultSource_default);

// node_modules/d3-random/src/weibull.js
var weibull_default = function sourceRandomWeibull(source) {
  function randomWeibull(k, a, b) {
    var outerFunc;
    if ((k = +k) === 0) {
      outerFunc = (x2) => -Math.log(x2);
    } else {
      k = 1 / k;
      outerFunc = (x2) => Math.pow(x2, k);
    }
    a = a == null ? 0 : +a;
    b = b == null ? 1 : +b;
    return function() {
      return a + b * outerFunc(-Math.log1p(-source()));
    };
  }
  randomWeibull.source = sourceRandomWeibull;
  return randomWeibull;
}(defaultSource_default);

// node_modules/d3-random/src/cauchy.js
var cauchy_default = function sourceRandomCauchy(source) {
  function randomCauchy(a, b) {
    a = a == null ? 0 : +a;
    b = b == null ? 1 : +b;
    return function() {
      return a + b * Math.tan(Math.PI * source());
    };
  }
  randomCauchy.source = sourceRandomCauchy;
  return randomCauchy;
}(defaultSource_default);

// node_modules/d3-random/src/logistic.js
var logistic_default = function sourceRandomLogistic(source) {
  function randomLogistic(a, b) {
    a = a == null ? 0 : +a;
    b = b == null ? 1 : +b;
    return function() {
      var u = source();
      return a + b * Math.log(u / (1 - u));
    };
  }
  randomLogistic.source = sourceRandomLogistic;
  return randomLogistic;
}(defaultSource_default);

// node_modules/d3-random/src/poisson.js
var poisson_default = function sourceRandomPoisson(source) {
  var G = gamma_default.source(source), B = binomial_default.source(source);
  function randomPoisson(lambda) {
    return function() {
      var acc = 0, l = lambda;
      while (l > 16) {
        var n = Math.floor(0.875 * l), t = G(n)();
        if (t > l)
          return acc + B(n - 1, l / t)();
        acc += n;
        l -= t;
      }
      for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k)
        s -= Math.log1p(-source());
      return acc + k;
    };
  }
  randomPoisson.source = sourceRandomPoisson;
  return randomPoisson;
}(defaultSource_default);

// node_modules/d3-random/src/lcg.js
var mul = 1664525;
var inc = 1013904223;
var eps = 1 / 4294967296;
function lcg(seed = Math.random()) {
  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
  return () => (state = mul * state + inc | 0, eps * (state >>> 0));
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1)
    t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c2 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x2;
  t = (0.5 - t) * Math.PI;
  c2.r = 255 * (x2 = Math.sin(t)) * x2;
  c2.g = 255 * (x2 = Math.sin(t + pi_1_3)) * x2;
  c2.b = 255 * (x2 = Math.sin(t + pi_2_3)) * x2;
  return c2 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n = range3.length;
  return function(t) {
    return range3[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/d3-zoom/src/transform.js
function Transform(k, x2, y2) {
  this.k = k;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity2;
  return node.__zoom;
}

// node_modules/@observablehq/plot/dist/context.js
function Context({ document: document2 = window.document } = {}) {
  return { document: document2 };
}
function create2(name, { document: document2 }) {
  return select_default2(creator_default(name).call(document2.documentElement));
}

// node_modules/isoformat/src/format.js
function format2(date, fallback) {
  if (!(date instanceof Date))
    date = new Date(+date);
  if (isNaN(date))
    return typeof fallback === "function" ? fallback(date) : fallback;
  const hours = date.getUTCHours();
  const minutes = date.getUTCMinutes();
  const seconds = date.getUTCSeconds();
  const milliseconds = date.getUTCMilliseconds();
  return `${formatYear2(date.getUTCFullYear(), 4)}-${pad2(date.getUTCMonth() + 1, 2)}-${pad2(date.getUTCDate(), 2)}${hours || minutes || seconds || milliseconds ? `T${pad2(hours, 2)}:${pad2(minutes, 2)}${seconds || milliseconds ? `:${pad2(seconds, 2)}${milliseconds ? `.${pad2(milliseconds, 3)}` : ``}` : ``}Z` : ``}`;
}
function formatYear2(year) {
  return year < 0 ? `-${pad2(-year, 6)}` : year > 9999 ? `+${pad2(year, 6)}` : pad2(year, 4);
}
function pad2(value, width) {
  return `${value}`.padStart(width, "0");
}

// node_modules/isoformat/src/parse.js
var re = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function parse(string2, fallback) {
  if (!re.test(string2 += ""))
    return typeof fallback === "function" ? fallback(string2) : fallback;
  return new Date(string2);
}

// node_modules/@observablehq/plot/dist/options.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var objectToString = Object.prototype.toString;
function valueof(data, value, type2) {
  const valueType = typeof value;
  return valueType === "string" ? map(data, field(value), type2) : valueType === "function" ? map(data, value, type2) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map(data, constant(value), type2) : value && typeof value.transform === "function" ? arrayify(value.transform(data), type2) : arrayify(value, type2);
}
var field = (name) => (d) => d[name];
var indexOf = (d, i) => i;
var identity3 = { transform: (d) => d };
var one = () => 1;
var yes = () => true;
var string = (x2) => x2 == null ? x2 : `${x2}`;
var number3 = (x2) => x2 == null ? x2 : +x2;
var boolean = (x2) => x2 == null ? x2 : !!x2;
var first = (x2) => x2 ? x2[0] : void 0;
var second = (x2) => x2 ? x2[1] : void 0;
var constant = (x2) => () => x2;
function percentile(reduce) {
  const p = +`${reduce}`.slice(1) / 100;
  return (I, f) => quantile(I, p, f);
}
function maybeColorChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
}
function maybeNumberChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
}
function maybeKeyword(input, name, allowed) {
  if (input != null)
    return keyword(input, name, allowed);
}
function keyword(input, name, allowed) {
  const i = `${input}`.toLowerCase();
  if (!allowed.includes(i))
    throw new Error(`invalid ${name}: ${input}`);
  return i;
}
function arrayify(data, type2) {
  return data == null ? data : type2 === void 0 ? data instanceof Array || data instanceof TypedArray ? data : Array.from(data) : data instanceof type2 ? data : type2.from(data);
}
function map(values2, f, type2 = Array) {
  return values2 instanceof type2 ? values2.map(f) : type2.from(values2, f);
}
function slice3(values2, type2 = Array) {
  return values2 instanceof type2 ? values2.slice() : type2.from(values2);
}
function isTypedArray(values2) {
  return values2 instanceof TypedArray;
}
function isObject(option) {
  return option?.toString === objectToString;
}
function isScaleOptions(option) {
  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
}
function isOptions(option) {
  return isObject(option) && typeof option.transform !== "function";
}
function isDomainSort(sort3) {
  return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;
}
function maybeZero(x2, x12, x22, x3 = identity3) {
  if (x12 === void 0 && x22 === void 0) {
    x12 = 0, x22 = x2 === void 0 ? x3 : x2;
  } else if (x12 === void 0) {
    x12 = x2 === void 0 ? 0 : x2;
  } else if (x22 === void 0) {
    x22 = x2 === void 0 ? 0 : x2;
  }
  return [x12, x22];
}
function maybeTuple(x2, y2) {
  return x2 === void 0 && y2 === void 0 ? [first, second] : [x2, y2];
}
function maybeZ({ z, fill, stroke } = {}) {
  if (z === void 0)
    [z] = maybeColorChannel(fill);
  if (z === void 0)
    [z] = maybeColorChannel(stroke);
  return z;
}
function range2(data) {
  const n = data.length;
  const r = new Uint32Array(n);
  for (let i = 0; i < n; ++i)
    r[i] = i;
  return r;
}
function where(data, test) {
  return range2(data).filter((i) => test(data[i], i, data));
}
function take(values2, index) {
  return map(index, (i) => values2[i]);
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function maybeInput(key, options) {
  if (options[key] !== void 0)
    return options[key];
  switch (key) {
    case "x1":
    case "x2":
      key = "x";
      break;
    case "y1":
    case "y2":
      key = "y";
      break;
  }
  return options[key];
}
function column(source) {
  let value;
  return [
    {
      transform: () => value,
      label: labelof(source)
    },
    (v) => value = v
  ];
}
function maybeColumn(source) {
  return source == null ? [source] : column(source);
}
function labelof(value, defaultValue) {
  return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
}
function mid(x12, x2) {
  return {
    transform(data) {
      const X12 = x12.transform(data);
      const X22 = x2.transform(data);
      return isTemporal(X12) || isTemporal(X22) ? map(X12, (_, i) => new Date((+X12[i] + +X22[i]) / 2)) : map(X12, (_, i) => (+X12[i] + +X22[i]) / 2, Float64Array);
    },
    label: x12.label
  };
}
function maybeValue(value) {
  return value === void 0 || isOptions(value) ? value : { value };
}
function numberChannel(source) {
  return source == null ? null : {
    transform: (data) => valueof(data, source, Float64Array),
    label: labelof(source)
  };
}
function isIterable(value) {
  return value && typeof value[Symbol.iterator] === "function";
}
function isTextual(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value !== "object" || value instanceof Date;
  }
}
function isOrdinal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    const type2 = typeof value;
    return type2 === "string" || type2 === "boolean";
  }
}
function isTemporal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return value instanceof Date;
  }
}
function isTemporalString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "string" && isNaN(value) && parse(value);
  }
}
function isNumericString(values2) {
  for (const value of values2) {
    if (value == null || value === "")
      continue;
    return typeof value === "string" && !isNaN(value);
  }
}
function isNumeric(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "number";
  }
}
function isFirst(values2, is) {
  for (const value of values2) {
    if (value == null)
      continue;
    return is(value);
  }
}
function isEvery(values2, is) {
  for (const value of values2) {
    if (value == null)
      continue;
    if (!is(value))
      return false;
  }
  return true;
}
function isColor(value) {
  if (typeof value !== "string")
    return false;
  value = value.toLowerCase().trim();
  return value === "none" || value === "currentcolor" || value.startsWith("url(") && value.endsWith(")") || value.startsWith("var(") && value.endsWith(")") || color(value) !== null;
}
function isNoneish(value) {
  return value == null || isNone(value);
}
function isNone(value) {
  return /^\s*none\s*$/i.test(value);
}
function isRound(value) {
  return /^\s*round\s*$/i.test(value);
}
function maybeFrameAnchor(value = "middle") {
  return keyword(value, "frameAnchor", [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function order(values2) {
  if (values2 == null)
    return;
  const first2 = values2[0];
  const last = values2[values2.length - 1];
  return descending(first2, last);
}
function inherit2(options = {}, ...rest) {
  let o = options;
  for (const defaults18 of rest) {
    for (const key in defaults18) {
      if (o[key] === void 0) {
        const value = defaults18[key];
        if (o === options)
          o = { ...o, [key]: value };
        else
          o[key] = value;
      }
    }
  }
  return o;
}
function Named(things) {
  console.warn("named iterables are deprecated; please use an object instead");
  const names = /* @__PURE__ */ new Set();
  return Object.fromEntries(Array.from(things, (thing) => {
    const { name } = thing;
    if (name == null)
      throw new Error("missing name");
    const key = `${name}`;
    if (key === "__proto__")
      throw new Error(`illegal name: ${key}`);
    if (names.has(key))
      throw new Error(`duplicate name: ${key}`);
    names.add(key);
    return [name, thing];
  }));
}
function maybeNamed(things) {
  return isIterable(things) ? Named(things) : things;
}

// node_modules/@observablehq/plot/dist/memoize.js
function memoize1(compute) {
  let cacheValue, cacheKeys;
  return (...keys) => {
    if (cacheKeys?.length !== keys.length || cacheKeys.some((k, i) => k !== keys[i])) {
      cacheKeys = keys;
      cacheValue = compute(...keys);
    }
    return cacheValue;
  };
}

// node_modules/@observablehq/plot/dist/format.js
var numberFormat = memoize1((locale) => new Intl.NumberFormat(locale));
var monthFormat = memoize1((locale, month) => new Intl.DateTimeFormat(locale, { timeZone: "UTC", ...month && { month } }));
var weekdayFormat = memoize1((locale, weekday) => new Intl.DateTimeFormat(locale, { timeZone: "UTC", ...weekday && { weekday } }));
function formatNumber(locale = "en-US") {
  const format3 = numberFormat(locale);
  return (i) => i != null && !isNaN(i) ? format3.format(i) : void 0;
}
function formatMonth(locale = "en-US", format3 = "short") {
  const fmt = monthFormat(locale, format3);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;
}
function formatWeekday(locale = "en-US", format3 = "short") {
  const fmt = weekdayFormat(locale, format3);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;
}
function formatIsoDate(date) {
  return format2(date, "Invalid Date");
}
function formatAuto(locale = "en-US") {
  const number4 = formatNumber(locale);
  return (v) => (v instanceof Date ? formatIsoDate : typeof v === "number" ? number4 : string)(v);
}
var formatDefault = formatAuto();

// node_modules/@observablehq/plot/dist/math.js
var radians2 = Math.PI / 180;

// node_modules/@observablehq/plot/dist/defined.js
function defined(x2) {
  return x2 != null && !Number.isNaN(x2);
}
function ascendingDefined(a, b) {
  return +defined(b) - +defined(a) || ascending(a, b);
}
function descendingDefined(a, b) {
  return +defined(b) - +defined(a) || descending(a, b);
}
function nonempty(x2) {
  return x2 != null && `${x2}` !== "";
}
function finite(x2) {
  return isFinite(x2) ? x2 : NaN;
}
function positive(x2) {
  return x2 > 0 && isFinite(x2) ? x2 : NaN;
}
function negative(x2) {
  return x2 < 0 && isFinite(x2) ? x2 : NaN;
}

// node_modules/@observablehq/plot/dist/warnings.js
var warnings = 0;
function consumeWarnings() {
  const w = warnings;
  warnings = 0;
  return w;
}
function warn(message) {
  console.warn(message);
  ++warnings;
}

// node_modules/@observablehq/plot/dist/style.js
var offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5;
var nextClipId = 0;
function styles(mark, { title, href, ariaLabel: variaLabel, ariaDescription, ariaHidden, target, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, opacity: opacity2, mixBlendMode, paintOrder, pointerEvents, shapeRendering }, { ariaLabel: cariaLabel, fill: defaultFill = "currentColor", fillOpacity: defaultFillOpacity, stroke: defaultStroke = "none", strokeOpacity: defaultStrokeOpacity, strokeWidth: defaultStrokeWidth, strokeLinecap: defaultStrokeLinecap, strokeLinejoin: defaultStrokeLinejoin, strokeMiterlimit: defaultStrokeMiterlimit, paintOrder: defaultPaintOrder }) {
  if (defaultFill === null) {
    fill = null;
    fillOpacity = null;
  }
  if (defaultStroke === null) {
    stroke = null;
    strokeOpacity = null;
  }
  if (isNoneish(defaultFill)) {
    if (!isNoneish(defaultStroke) && !isNoneish(fill))
      defaultStroke = "none";
  } else {
    if (isNoneish(defaultStroke) && !isNoneish(stroke))
      defaultFill = "none";
  }
  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
  const [vopacity, copacity] = maybeNumberChannel(opacity2);
  if (!isNone(cstroke)) {
    if (strokeWidth === void 0)
      strokeWidth = defaultStrokeWidth;
    if (strokeLinecap === void 0)
      strokeLinecap = defaultStrokeLinecap;
    if (strokeLinejoin === void 0)
      strokeLinejoin = defaultStrokeLinejoin;
    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))
      strokeMiterlimit = defaultStrokeMiterlimit;
    if (!isNone(cfill) && paintOrder === void 0)
      paintOrder = defaultPaintOrder;
  }
  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
  if (defaultFill !== null) {
    mark.fill = impliedString(cfill, "currentColor");
    mark.fillOpacity = impliedNumber(cfillOpacity, 1);
  }
  if (defaultStroke !== null) {
    mark.stroke = impliedString(cstroke, "none");
    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
    mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
    mark.strokeLinecap = impliedString(strokeLinecap, "butt");
    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
    mark.strokeDasharray = impliedString(strokeDasharray, "none");
    mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
  }
  mark.target = string(target);
  mark.ariaLabel = string(cariaLabel);
  mark.ariaDescription = string(ariaDescription);
  mark.ariaHidden = string(ariaHidden);
  mark.opacity = impliedNumber(copacity, 1);
  mark.mixBlendMode = impliedString(mixBlendMode, "normal");
  mark.paintOrder = impliedString(paintOrder, "normal");
  mark.pointerEvents = impliedString(pointerEvents, "auto");
  mark.shapeRendering = impliedString(shapeRendering, "auto");
  return {
    title: { value: title, optional: true },
    href: { value: href, optional: true },
    ariaLabel: { value: variaLabel, optional: true },
    fill: { value: vfill, scale: "color", optional: true },
    fillOpacity: { value: vfillOpacity, scale: "opacity", optional: true },
    stroke: { value: vstroke, scale: "color", optional: true },
    strokeOpacity: { value: vstrokeOpacity, scale: "opacity", optional: true },
    strokeWidth: { value: vstrokeWidth, optional: true },
    opacity: { value: vopacity, scale: "opacity", optional: true }
  };
}
function applyTitle(selection2, L) {
  if (L)
    selection2.filter((i) => nonempty(L[i])).append("title").call(applyText, L);
}
function applyTitleGroup(selection2, L) {
  if (L)
    selection2.filter(([i]) => nonempty(L[i])).append("title").call(applyTextGroup, L);
}
function applyText(selection2, T) {
  if (T)
    selection2.text((i) => formatDefault(T[i]));
}
function applyTextGroup(selection2, T) {
  if (T)
    selection2.text(([i]) => formatDefault(T[i]));
}
function applyChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {
  if (AL)
    applyAttr(selection2, "aria-label", (i) => AL[i]);
  if (F)
    applyAttr(selection2, "fill", (i) => F[i]);
  if (FO)
    applyAttr(selection2, "fill-opacity", (i) => FO[i]);
  if (S)
    applyAttr(selection2, "stroke", (i) => S[i]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", (i) => SO[i]);
  if (SW)
    applyAttr(selection2, "stroke-width", (i) => SW[i]);
  if (O)
    applyAttr(selection2, "opacity", (i) => O[i]);
  if (H)
    applyHref(selection2, (i) => H[i], target);
  applyTitle(selection2, T);
}
function applyGroupedChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {
  if (AL)
    applyAttr(selection2, "aria-label", ([i]) => AL[i]);
  if (F)
    applyAttr(selection2, "fill", ([i]) => F[i]);
  if (FO)
    applyAttr(selection2, "fill-opacity", ([i]) => FO[i]);
  if (S)
    applyAttr(selection2, "stroke", ([i]) => S[i]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", ([i]) => SO[i]);
  if (SW)
    applyAttr(selection2, "stroke-width", ([i]) => SW[i]);
  if (O)
    applyAttr(selection2, "opacity", ([i]) => O[i]);
  if (H)
    applyHref(selection2, ([i]) => H[i], target);
  applyTitleGroup(selection2, T);
}
function groupAesthetics({ ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {
  return [AL, T, F, FO, S, SO, SW, O, H].filter((c3) => c3 !== void 0);
}
function groupZ(I, Z, z) {
  const G = group(I, (i) => Z[i]);
  if (z === void 0 && G.size > I.length >> 1) {
    warn(`Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`);
  }
  return G.values();
}
function* groupIndex(I, position2, { z }, channels) {
  const { z: Z } = channels;
  const A = groupAesthetics(channels);
  const C = [...position2, ...A];
  for (const G of Z ? groupZ(I, Z, z) : [I]) {
    let Ag;
    let Gg;
    out:
      for (const i of G) {
        for (const c3 of C) {
          if (!defined(c3[i])) {
            if (Gg)
              Gg.push(-1);
            continue out;
          }
        }
        if (Ag === void 0) {
          if (Gg)
            yield Gg;
          Ag = A.map((c3) => keyof(c3[i])), Gg = [i];
          continue;
        }
        Gg.push(i);
        for (let j = 0; j < A.length; ++j) {
          const k = keyof(A[j][i]);
          if (k !== Ag[j]) {
            yield Gg;
            Ag = A.map((c3) => keyof(c3[i])), Gg = [i];
            continue out;
          }
        }
      }
    if (Gg)
      yield Gg;
  }
}
function maybeClip(clip) {
  if (clip === true)
    return "frame";
  if (clip == null || clip === false)
    return false;
  throw new Error(`invalid clip method: ${clip}`);
}
function applyIndirectStyles(selection2, mark, scales, dimensions) {
  applyAttr(selection2, "aria-label", mark.ariaLabel);
  applyAttr(selection2, "aria-description", mark.ariaDescription);
  applyAttr(selection2, "aria-hidden", mark.ariaHidden);
  applyAttr(selection2, "fill", mark.fill);
  applyAttr(selection2, "fill-opacity", mark.fillOpacity);
  applyAttr(selection2, "stroke", mark.stroke);
  applyAttr(selection2, "stroke-width", mark.strokeWidth);
  applyAttr(selection2, "stroke-opacity", mark.strokeOpacity);
  applyAttr(selection2, "stroke-linejoin", mark.strokeLinejoin);
  applyAttr(selection2, "stroke-linecap", mark.strokeLinecap);
  applyAttr(selection2, "stroke-miterlimit", mark.strokeMiterlimit);
  applyAttr(selection2, "stroke-dasharray", mark.strokeDasharray);
  applyAttr(selection2, "stroke-dashoffset", mark.strokeDashoffset);
  applyAttr(selection2, "shape-rendering", mark.shapeRendering);
  applyAttr(selection2, "paint-order", mark.paintOrder);
  applyAttr(selection2, "pointer-events", mark.pointerEvents);
  if (mark.clip === "frame") {
    const { x: x2, y: y2 } = scales;
    const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
    const id2 = `plot-clip-${++nextClipId}`;
    selection2.attr("clip-path", `url(#${id2})`).append("clipPath").attr("id", id2).append("rect").attr("x", marginLeft - (x2?.bandwidth ? x2.bandwidth() / 2 : 0)).attr("y", marginTop - (y2?.bandwidth ? y2.bandwidth() / 2 : 0)).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom);
  }
}
function applyDirectStyles(selection2, mark) {
  applyStyle(selection2, "mix-blend-mode", mark.mixBlendMode);
  applyAttr(selection2, "opacity", mark.opacity);
}
function applyHref(selection2, href, target) {
  selection2.each(function(i) {
    const h = href(i);
    if (h != null) {
      const a = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
      a.setAttribute("fill", "inherit");
      a.setAttributeNS(namespaces_default.xlink, "href", h);
      if (target != null)
        a.setAttribute("target", target);
      this.parentNode.insertBefore(a, this).appendChild(this);
    }
  });
}
function applyAttr(selection2, name, value) {
  if (value != null)
    selection2.attr(name, value);
}
function applyStyle(selection2, name, value) {
  if (value != null)
    selection2.style(name, value);
}
function applyTransform(selection2, mark, { x: x2, y: y2 }, tx = offset, ty = offset) {
  tx += mark.dx;
  ty += mark.dy;
  if (x2?.bandwidth)
    tx += x2.bandwidth() / 2;
  if (y2?.bandwidth)
    ty += y2.bandwidth() / 2;
  if (tx || ty)
    selection2.attr("transform", `translate(${tx},${ty})`);
}
function impliedString(value, impliedValue) {
  if ((value = string(value)) !== impliedValue)
    return value;
}
function impliedNumber(value, impliedValue) {
  if ((value = number3(value)) !== impliedValue)
    return value;
}
var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/;
function maybeClassName(name) {
  if (name === void 0)
    return `plot-${Math.random().toString(16).slice(2)}`;
  name = `${name}`;
  if (!validClassName.test(name))
    throw new Error(`invalid class name: ${name}`);
  return name;
}
function applyInlineStyles(selection2, style) {
  if (typeof style === "string") {
    selection2.property("style", style);
  } else if (style != null) {
    for (const element of selection2) {
      Object.assign(element.style, style);
    }
  }
}
function applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {
  return [
    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
  ];
}

// node_modules/@observablehq/plot/dist/axis.js
var AxisX = class {
  constructor({ name = "x", axis: axis2, ticks: ticks2, tickSize = name === "fx" ? 0 : 6, tickPadding = tickSize === 0 ? 9 : 3, tickFormat, fontVariant, grid, label, labelAnchor, labelOffset, line: line2, tickRotate, ariaLabel, ariaDescription } = {}) {
    this.name = name;
    this.axis = keyword(axis2, "axis", ["top", "bottom"]);
    this.ticks = maybeTicks(ticks2);
    this.tickSize = number3(tickSize);
    this.tickPadding = number3(tickPadding);
    this.tickFormat = maybeTickFormat(tickFormat);
    this.fontVariant = impliedString(fontVariant, "normal");
    this.grid = boolean(grid);
    this.label = string(label);
    this.labelAnchor = maybeKeyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
    this.labelOffset = number3(labelOffset);
    this.line = boolean(line2);
    this.tickRotate = number3(tickRotate);
    this.ariaLabel = string(ariaLabel);
    this.ariaDescription = string(ariaDescription);
  }
  render(index, { [this.name]: x2, fy }, { width, height, marginTop, marginRight, marginBottom, marginLeft, offsetLeft = 0, facetMarginTop, facetMarginBottom, labelMarginLeft = 0, labelMarginRight = 0 }, context) {
    const { axis: axis2, fontVariant, grid, label, labelAnchor, labelOffset, line: line2, name, tickRotate } = this;
    const offset2 = name === "x" ? 0 : axis2 === "top" ? marginTop - facetMarginTop : marginBottom - facetMarginBottom;
    const offsetSign = axis2 === "top" ? -1 : 1;
    const ty = offsetSign * offset2 + (axis2 === "top" ? marginTop : height - marginBottom);
    return create2("svg:g", context).call(applyAria, this).attr("transform", `translate(${offsetLeft},${ty})`).call(createAxis(axis2 === "top" ? axisTop : axisBottom, x2, this)).call(maybeTickRotate, tickRotate).attr("font-size", null).attr("font-family", null).attr("font-variant", fontVariant).call(!line2 ? (g) => g.select(".domain").remove() : () => {
    }).call(!grid ? () => {
    } : fy ? gridFacetX(index, fy, -ty) : gridX(offsetSign * (marginBottom + marginTop - height))).call(!label ? () => {
    } : (g) => g.append("text").attr("fill", "currentColor").attr("transform", `translate(${labelAnchor === "center" ? (width + marginLeft - marginRight) / 2 : labelAnchor === "right" ? width + labelMarginRight : -labelMarginLeft},${labelOffset * offsetSign})`).attr("dy", axis2 === "top" ? "1em" : "-0.32em").attr("text-anchor", labelAnchor === "center" ? "middle" : labelAnchor === "right" ? "end" : "start").text(label)).node();
  }
};
var AxisY = class {
  constructor({ name = "y", axis: axis2, ticks: ticks2, tickSize = name === "fy" ? 0 : 6, tickPadding = tickSize === 0 ? 9 : 3, tickFormat, fontVariant, grid, label, labelAnchor, labelOffset, line: line2, tickRotate, ariaLabel, ariaDescription } = {}) {
    this.name = name;
    this.axis = keyword(axis2, "axis", ["left", "right"]);
    this.ticks = maybeTicks(ticks2);
    this.tickSize = number3(tickSize);
    this.tickPadding = number3(tickPadding);
    this.tickFormat = maybeTickFormat(tickFormat);
    this.fontVariant = impliedString(fontVariant, "normal");
    this.grid = boolean(grid);
    this.label = string(label);
    this.labelAnchor = maybeKeyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
    this.labelOffset = number3(labelOffset);
    this.line = boolean(line2);
    this.tickRotate = number3(tickRotate);
    this.ariaLabel = string(ariaLabel);
    this.ariaDescription = string(ariaDescription);
  }
  render(index, { [this.name]: y2, fx }, { width, height, marginTop, marginRight, marginBottom, marginLeft, offsetTop = 0, facetMarginLeft, facetMarginRight }, context) {
    const { axis: axis2, fontVariant, grid, label, labelAnchor, labelOffset, line: line2, name, tickRotate } = this;
    const offset2 = name === "y" ? 0 : axis2 === "left" ? marginLeft - facetMarginLeft : marginRight - facetMarginRight;
    const offsetSign = axis2 === "left" ? -1 : 1;
    const tx = offsetSign * offset2 + (axis2 === "right" ? width - marginRight : marginLeft);
    return create2("svg:g", context).call(applyAria, this).attr("transform", `translate(${tx},${offsetTop})`).call(createAxis(axis2 === "right" ? axisRight : axisLeft, y2, this)).call(maybeTickRotate, tickRotate).attr("font-size", null).attr("font-family", null).attr("font-variant", fontVariant).call(!line2 ? (g) => g.select(".domain").remove() : () => {
    }).call(!grid ? () => {
    } : fx ? gridFacetY(index, fx, -tx) : gridY(offsetSign * (marginLeft + marginRight - width))).call(!label ? () => {
    } : (g) => g.append("text").attr("fill", "currentColor").attr("font-variant", fontVariant == null ? null : "normal").attr("transform", `translate(${labelOffset * offsetSign},${labelAnchor === "center" ? (height + marginTop - marginBottom) / 2 : labelAnchor === "bottom" ? height - marginBottom : marginTop})${labelAnchor === "center" ? ` rotate(-90)` : ""}`).attr("dy", labelAnchor === "center" ? axis2 === "right" ? "-0.32em" : "0.75em" : labelAnchor === "bottom" ? "1.4em" : "-1em").attr("text-anchor", labelAnchor === "center" ? "middle" : axis2 === "right" ? "end" : "start").text(label)).node();
  }
};
function applyAria(selection2, { name, label, ariaLabel = `${name}-axis`, ariaDescription = label }) {
  applyAttr(selection2, "aria-label", ariaLabel);
  applyAttr(selection2, "aria-description", ariaDescription);
}
function gridX(y2) {
  return (g) => g.selectAll(".tick line").clone(true).attr("stroke-opacity", 0.1).attr("y2", y2);
}
function gridY(x2) {
  return (g) => g.selectAll(".tick line").clone(true).attr("stroke-opacity", 0.1).attr("x2", x2);
}
function gridFacetX(index, fy, ty) {
  const dy = fy.bandwidth();
  const domain = fy.domain();
  return (g) => g.selectAll(".tick").append("path").attr("stroke", "currentColor").attr("stroke-opacity", 0.1).attr("d", (index ? take(domain, index) : domain).map((v) => `M0,${fy(v) + ty}v${dy}`).join(""));
}
function gridFacetY(index, fx, tx) {
  const dx = fx.bandwidth();
  const domain = fx.domain();
  return (g) => g.selectAll(".tick").append("path").attr("stroke", "currentColor").attr("stroke-opacity", 0.1).attr("d", (index ? take(domain, index) : domain).map((v) => `M${fx(v) + tx},0h${dx}`).join(""));
}
function maybeTicks(ticks2) {
  return ticks2 === null ? [] : ticks2;
}
function maybeTickFormat(tickFormat) {
  return tickFormat === null ? () => null : tickFormat;
}
function maybeAutoTickFormat(tickFormat, domain) {
  return tickFormat === void 0 ? isTemporal(domain) ? formatIsoDate : string : typeof tickFormat === "function" ? tickFormat : (typeof tickFormat === "string" ? isTemporal(domain) ? utcFormat : format : constant)(tickFormat);
}
function createAxis(axis2, scale2, { ticks: ticks2, tickSize, tickPadding, tickFormat }) {
  if (!scale2.tickFormat) {
    tickFormat = maybeAutoTickFormat(tickFormat, scale2.domain());
  }
  return axis2(scale2).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat === "function" ? null : tickFormat).tickFormat(typeof tickFormat === "function" ? tickFormat : null).tickSizeInner(tickSize).tickSizeOuter(0).tickPadding(tickPadding).tickValues(Array.isArray(ticks2) ? ticks2 : null);
}
function maybeTickRotate(g, rotate) {
  if (!(rotate = +rotate))
    return;
  for (const text2 of g.selectAll("text")) {
    const x2 = +text2.getAttribute("x");
    const y2 = +text2.getAttribute("y");
    if (Math.abs(y2) > Math.abs(x2)) {
      const s = Math.sign(y2);
      text2.setAttribute("transform", `translate(0, ${y2 + s * 4 * Math.cos(rotate * radians2)}) rotate(${rotate})`);
      text2.setAttribute("text-anchor", Math.abs(rotate) < 10 ? "middle" : rotate < 0 ^ s > 0 ? "start" : "end");
    } else {
      const s = Math.sign(x2);
      text2.setAttribute("transform", `translate(${x2 + s * 4 * Math.abs(Math.sin(rotate * radians2))}, 0) rotate(${rotate})`);
      text2.setAttribute("text-anchor", Math.abs(rotate) > 60 ? "middle" : s > 0 ? "start" : "end");
    }
    text2.removeAttribute("x");
    text2.removeAttribute("y");
    text2.setAttribute("dy", "0.32em");
  }
}

// node_modules/@observablehq/plot/dist/scales/index.js
var position = Symbol("position");
var color2 = Symbol("color");
var radius = Symbol("radius");
var length = Symbol("length");
var opacity = Symbol("opacity");
var symbol = Symbol("symbol");
var registry = /* @__PURE__ */ new Map([
  ["x", position],
  ["y", position],
  ["fx", position],
  ["fy", position],
  ["r", radius],
  ["color", color2],
  ["opacity", opacity],
  ["symbol", symbol],
  ["length", length]
]);

// node_modules/@observablehq/plot/dist/scales/schemes.js
var ordinalSchemes = /* @__PURE__ */ new Map([
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default],
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function scheme92(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 1)
      return [scheme28[3][1]];
    if (n === 2)
      return [scheme28[3][1], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme112(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2)
      return [scheme28[3][0], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme11r(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2)
      return [scheme28[3][2], scheme28[3][0]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();
  };
}
function schemei(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));
}
function schemeicyclical(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s = `${scheme28}`.toLowerCase();
  if (!ordinalSchemes.has(s))
    throw new Error(`unknown scheme: ${s}`);
  return ordinalSchemes.get(s);
}
function ordinalRange(scheme28, length2) {
  const s = ordinalScheme(scheme28);
  const r = typeof s === "function" ? s({ length: length2 }) : s;
  return r.length !== length2 ? r.slice(0, length2) : r;
}
function maybeBooleanRange(domain, scheme28 = "greys") {
  const range3 = /* @__PURE__ */ new Set();
  const [f, t] = ordinalRange(scheme28, 2);
  for (const value of domain) {
    if (value == null)
      continue;
    if (value === true)
      range3.add(t);
    else if (value === false)
      range3.add(f);
    else
      return;
  }
  return [...range3];
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  ["burd", (t) => RdBu_default(1 - t)],
  ["buylrd", (t) => RdYlBu_default(1 - t)],
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function quantitativeScheme(scheme28) {
  const s = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s))
    throw new Error(`unknown scheme: ${s}`);
  return quantitativeSchemes.get(s);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}

// node_modules/@observablehq/plot/dist/transforms/inset.js
function maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {
  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
  return { inset, insetLeft, insetRight, ...options };
}
function maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {
  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
  return { inset, insetTop, insetBottom, ...options };
}
function maybeInset(inset, inset1, inset2) {
  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
}

// node_modules/@observablehq/plot/dist/transforms/interval.js
function maybeInterval(interval2) {
  if (interval2 == null)
    return;
  if (typeof interval2 === "number") {
    const n = interval2;
    return {
      floor: (d) => n * Math.floor(d / n),
      offset: (d) => d + n,
      range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x2) => n * x2)
    };
  }
  if (typeof interval2.floor !== "function" || typeof interval2.offset !== "function")
    throw new Error("invalid interval; missing floor or offset function");
  return interval2;
}
function maybeIntervalValue(value, { interval: interval2 }) {
  value = { ...maybeValue(value) };
  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);
  return value;
}
function maybeIntervalK(k, maybeInsetK, options, trivial) {
  const { [k]: v, [`${k}1`]: v1, [`${k}2`]: v2 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v, options);
  if (value == null || interval2 == null && !trivial)
    return options;
  const label = labelof(v);
  if (interval2 == null) {
    let V;
    const kv = { transform: (data) => V || (V = valueof(data, value)), label };
    return {
      ...options,
      [k]: void 0,
      [`${k}1`]: v1 === void 0 ? kv : v1,
      [`${k}2`]: v2 === void 0 ? kv : v2
    };
  }
  let D1, V1;
  function transform2(data) {
    if (V1 !== void 0 && data === D1)
      return V1;
    return V1 = map(valueof(D1 = data, value), (v3) => interval2.floor(v3));
  }
  return maybeInsetK({
    ...options,
    [k]: void 0,
    [`${k}1`]: v1 === void 0 ? { transform: transform2, label } : v1,
    [`${k}2`]: v2 === void 0 ? { transform: (data) => transform2(data).map((v3) => interval2.offset(v3)), label } : v2
  });
}
function maybeIntervalMidK(k, maybeInsetK, options) {
  const { [k]: v } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v, options);
  if (value == null || interval2 == null)
    return options;
  return maybeInsetK({
    ...options,
    [k]: {
      label: labelof(v),
      transform: (data) => {
        const V1 = map(valueof(data, value), (v2) => interval2.floor(v2));
        const V2 = V1.map((v2) => interval2.offset(v2));
        return V1.map(isTemporal(V1) ? (v1, v2) => v1 == null || isNaN(v1 = +v1) || (v2 = V2[v2], v2 == null) || isNaN(v2 = +v2) ? void 0 : new Date((v1 + v2) / 2) : (v1, v2) => v1 == null || (v2 = V2[v2], v2 == null) ? NaN : (+v1 + +v2) / 2);
      }
    }
  });
}
function maybeTrivialIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options, true);
}
function maybeTrivialIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options, true);
}
function maybeIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options);
}
function maybeIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options);
}
function maybeIntervalMidX(options = {}) {
  return maybeIntervalMidK("x", maybeInsetX, options);
}
function maybeIntervalMidY(options = {}) {
  return maybeIntervalMidK("y", maybeInsetY, options);
}

// node_modules/@observablehq/plot/dist/scales/quantitative.js
var flip = (i) => (t) => i(1 - t);
var unit = [0, 1];
var interpolators = /* @__PURE__ */ new Map([
  ["number", number_default],
  ["rgb", rgb_default],
  ["hsl", hsl_default],
  ["hcl", hcl_default],
  ["lab", lab]
]);
function Interpolator(interpolate) {
  const i = `${interpolate}`.toLowerCase();
  if (!interpolators.has(i))
    throw new Error(`unknown interpolator: ${i}`);
  return interpolators.get(i);
}
function ScaleQ(key, scale2, channels, { type: type2, nice, clamp, zero, domain = inferAutoDomain(key, channels), unknown, round, scheme: scheme28, interval: interval2, range: range3 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit : void 0, interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === "cyclical" ? "rainbow" : "turbo") : round ? round_default : number_default, reverse: reverse3 }) {
  interval2 = maybeInterval(interval2);
  if (type2 === "cyclical" || type2 === "sequential")
    type2 = "linear";
  reverse3 = !!reverse3;
  if (typeof interpolate !== "function") {
    interpolate = Interpolator(interpolate);
  }
  if (interpolate.length === 1) {
    if (reverse3) {
      interpolate = flip(interpolate);
      reverse3 = false;
    }
    if (range3 === void 0) {
      range3 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
      if (range3.length === 2)
        range3 = unit;
    }
    scale2.interpolate((range3 === unit ? constant : interpolatePiecewise)(interpolate));
  } else {
    scale2.interpolate(interpolate);
  }
  if (zero) {
    const [min3, max4] = extent(domain);
    if (min3 > 0 || max4 < 0) {
      domain = slice3(domain);
      if (order(domain) !== Math.sign(min3))
        domain[domain.length - 1] = 0;
      else
        domain[0] = 0;
    }
  }
  if (reverse3)
    domain = reverse(domain);
  scale2.domain(domain).unknown(unknown);
  if (nice)
    scale2.nice(nice === true ? void 0 : nice), domain = scale2.domain();
  if (range3 !== void 0)
    scale2.range(range3);
  if (clamp)
    scale2.clamp(clamp);
  return { type: type2, domain, range: range3, scale: scale2, interpolate, interval: interval2 };
}
function ScaleLinear(key, channels, options) {
  return ScaleQ(key, linear(), channels, options);
}
function ScaleSqrt(key, channels, options) {
  return ScalePow(key, channels, { ...options, exponent: 0.5 });
}
function ScalePow(key, channels, { exponent: exponent2 = 1, ...options }) {
  return ScaleQ(key, pow().exponent(exponent2), channels, { ...options, type: "pow" });
}
function ScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
  return ScaleQ(key, log().base(base), channels, { ...options, domain });
}
function ScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return ScaleQ(key, symlog().constant(constant2), channels, options);
}
function ScaleQuantile(key, channels, {
  range: range3,
  quantiles = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  n = quantiles,
  scheme: scheme28 = "rdylbu",
  domain = inferQuantileDomain(channels),
  interpolate,
  reverse: reverse3
}) {
  if (range3 === void 0)
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;
  return ScaleThreshold(key, channels, {
    domain: quantile2(domain, range3 === void 0 ? { length: n } : range3).quantiles(),
    range: range3,
    reverse: reverse3
  });
}
function ScaleQuantize(key, channels, { range: range3, n = range3 === void 0 ? 5 : (range3 = [...range3]).length, scheme: scheme28 = "rdylbu", domain = inferAutoDomain(key, channels), interpolate, reverse: reverse3 }) {
  const [min3, max4] = extent(domain);
  let thresholds;
  if (range3 === void 0) {
    thresholds = ticks(min3, max4, n);
    if (thresholds[0] <= min3)
      thresholds.splice(0, 1);
    if (thresholds[thresholds.length - 1] >= max4)
      thresholds.pop();
    n = thresholds.length + 1;
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;
  } else {
    thresholds = quantize_default(number_default(min3, max4), n + 1).slice(1, -1);
    if (min3 instanceof Date)
      thresholds = thresholds.map((x2) => new Date(x2));
  }
  if (order(arrayify(domain)) < 0)
    thresholds.reverse();
  return ScaleThreshold(key, channels, { domain: thresholds, range: range3, reverse: reverse3 });
}
function ScaleThreshold(key, channels, {
  domain = [0],
  unknown,
  scheme: scheme28 = "rdylbu",
  interpolate,
  range: range3 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,
  reverse: reverse3
}) {
  const sign2 = order(arrayify(domain));
  if (!pairs(domain).every(([a, b]) => isOrdered(a, b, sign2)))
    throw new Error(`the ${key} scale has a non-monotonic domain`);
  if (reverse3)
    range3 = reverse(range3);
  return {
    type: "threshold",
    scale: threshold(sign2 < 0 ? reverse(domain) : domain, range3 === void 0 ? [] : range3).unknown(unknown),
    domain,
    range: range3
  };
}
function isOrdered(a, b, sign2) {
  const s = descending(a, b);
  return s === 0 || s === sign2;
}
function ScaleIdentity() {
  return { type: "identity", scale: identity() };
}
function inferDomain(channels, f = finite) {
  return channels.length ? [
    min(channels, ({ value }) => value === void 0 ? value : min(value, f)),
    max(channels, ({ value }) => value === void 0 ? value : max(value, f))
  ] : [0, 1];
}
function inferAutoDomain(key, channels) {
  const type2 = registry.get(key);
  return (type2 === radius || type2 === opacity || type2 === length ? inferZeroDomain : inferDomain)(channels);
}
function inferZeroDomain(channels) {
  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite)) : 1];
}
function inferRadialRange(channels, domain) {
  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
  if (hint !== void 0)
    return [0, hint.radius];
  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
  const range3 = domain.map((d) => 3 * Math.sqrt(d / h25));
  const k = 30 / max(range3);
  return k < 1 ? range3.map((r) => r * k) : range3;
}
function inferLengthRange(channels, domain) {
  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
  const range3 = domain.map((d) => 12 * d / h50);
  const k = 60 / max(range3);
  return k < 1 ? range3.map((r) => r * k) : range3;
}
function inferLogDomain(channels) {
  for (const { value } of channels) {
    if (value !== void 0) {
      for (let v of value) {
        v = +v;
        if (v > 0)
          return inferDomain(channels, positive);
        if (v < 0)
          return inferDomain(channels, negative);
      }
    }
  }
  return [1, 10];
}
function inferQuantileDomain(channels) {
  const domain = [];
  for (const { value } of channels) {
    if (value === void 0)
      continue;
    for (const v of value)
      domain.push(v);
  }
  return domain;
}
function interpolatePiecewise(interpolate) {
  return (i, j) => (t) => interpolate(i + t * (j - i));
}

// node_modules/@observablehq/plot/dist/scales/diverging.js
function ScaleD(key, scale2, transform2, channels, { type: type2, nice, clamp, domain = inferDomain(channels), unknown, pivot = 0, scheme: scheme28, range: range3, symmetric = true, interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default, reverse: reverse3 }) {
  pivot = +pivot;
  let [min3, max4] = domain;
  min3 = Math.min(min3, pivot);
  max4 = Math.max(max4, pivot);
  if (typeof interpolate !== "function") {
    interpolate = Interpolator(interpolate);
  }
  if (range3 !== void 0) {
    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range3) : piecewise(interpolate, range3);
  }
  if (reverse3)
    interpolate = flip(interpolate);
  if (symmetric) {
    const mid3 = transform2.apply(pivot);
    const mindelta = mid3 - transform2.apply(min3);
    const maxdelta = transform2.apply(max4) - mid3;
    if (mindelta < maxdelta)
      min3 = transform2.invert(mid3 - maxdelta);
    else if (mindelta > maxdelta)
      max4 = transform2.invert(mid3 + mindelta);
  }
  scale2.domain([min3, pivot, max4]).unknown(unknown).interpolator(interpolate);
  if (clamp)
    scale2.clamp(clamp);
  if (nice)
    scale2.nice(nice);
  return { type: type2, domain: [min3, max4], pivot, interpolate, scale: scale2 };
}
function ScaleDiverging(key, channels, options) {
  return ScaleD(key, diverging(), transformIdentity, channels, options);
}
function ScaleDivergingSqrt(key, channels, options) {
  return ScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
}
function ScaleDivergingPow(key, channels, { exponent: exponent2 = 1, ...options }) {
  return ScaleD(key, divergingPow().exponent(exponent2 = +exponent2), transformPow(exponent2), channels, {
    ...options,
    type: "diverging-pow"
  });
}
function ScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {
  return ScaleD(key, divergingLog().base(base = +base), transformLog, channels, { domain, pivot, ...options });
}
function ScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return ScaleD(key, divergingSymlog().constant(constant2 = +constant2), transformSymlog(constant2), channels, options);
}
var transformIdentity = {
  apply(x2) {
    return x2;
  },
  invert(x2) {
    return x2;
  }
};
var transformLog = {
  apply: Math.log,
  invert: Math.exp
};
var transformSqrt = {
  apply(x2) {
    return Math.sign(x2) * Math.sqrt(Math.abs(x2));
  },
  invert(x2) {
    return Math.sign(x2) * (x2 * x2);
  }
};
function transformPow(exponent2) {
  return exponent2 === 0.5 ? transformSqrt : {
    apply(x2) {
      return Math.sign(x2) * Math.pow(Math.abs(x2), exponent2);
    },
    invert(x2) {
      return Math.sign(x2) * Math.pow(Math.abs(x2), 1 / exponent2);
    }
  };
}
function transformSymlog(constant2) {
  return {
    apply(x2) {
      return Math.sign(x2) * Math.log1p(Math.abs(x2 / constant2));
    },
    invert(x2) {
      return Math.sign(x2) * Math.expm1(Math.abs(x2)) * constant2;
    }
  };
}

// node_modules/@observablehq/plot/dist/scales/temporal.js
function ScaleT(key, scale2, channels, options) {
  return ScaleQ(key, scale2, channels, options);
}
function ScaleTime(key, channels, options) {
  return ScaleT(key, time(), channels, options);
}
function ScaleUtc(key, channels, options) {
  return ScaleT(key, utcTime(), channels, options);
}

// node_modules/@observablehq/plot/dist/symbols.js
var sqrt3 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt3;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", x_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  return value && typeof value.draw === "function";
}
function isSymbol(value) {
  if (isSymbolObject(value))
    return true;
  if (typeof value !== "string")
    return false;
  return symbols.has(value.toLowerCase());
}
function maybeSymbol(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return symbol2;
  const value = symbols.get(`${symbol2}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid symbol: ${symbol2}`);
}
function maybeSymbolChannel(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return [void 0, symbol2];
  if (typeof symbol2 === "string") {
    const value = symbols.get(`${symbol2}`.toLowerCase());
    if (value)
      return [void 0, value];
  }
  return [symbol2, void 0];
}

// node_modules/@observablehq/plot/dist/scales/ordinal.js
var ordinalImplicit = Symbol("ordinal");
function ScaleO(key, scale2, channels, { type: type2, interval: interval2, domain, range: range3, reverse: reverse3, hint }) {
  interval2 = maybeInterval(interval2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  if (type2 === "categorical" || type2 === ordinalImplicit)
    type2 = "ordinal";
  if (reverse3)
    domain = reverse(domain);
  scale2.domain(domain);
  if (range3 !== void 0) {
    if (typeof range3 === "function")
      range3 = range3(domain);
    scale2.range(range3);
  }
  return { type: type2, domain, range: range3, scale: scale2, hint, interval: interval2 };
}
function ScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range3, scheme: scheme28, unknown, ...options }) {
  interval2 = maybeInterval(interval2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  let hint;
  if (registry.get(key) === symbol) {
    hint = inferSymbolHint(channels);
    range3 = range3 === void 0 ? inferSymbolRange(hint) : map(range3, maybeSymbol);
  } else if (registry.get(key) === color2) {
    if (range3 === void 0 && (type2 === "ordinal" || type2 === ordinalImplicit)) {
      range3 = maybeBooleanRange(domain, scheme28);
      if (range3 !== void 0)
        scheme28 = void 0;
    }
    if (scheme28 === void 0 && range3 === void 0) {
      scheme28 = type2 === "ordinal" ? "turbo" : "tableau10";
    }
    if (scheme28 !== void 0) {
      if (range3 !== void 0) {
        const interpolate = quantitativeScheme(scheme28);
        const t0 = range3[0], d = range3[1] - range3[0];
        range3 = ({ length: n }) => quantize_default((t) => interpolate(t0 + d * t), n);
      } else {
        range3 = ordinalScheme(scheme28);
      }
    }
  }
  if (unknown === implicit)
    throw new Error("implicit unknown is not supported");
  return ScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range3, hint });
}
function ScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
  return maybeRound(point().align(align).padding(padding), channels, options, key);
}
function ScaleBand(key, channels, { align = 0.5, padding = 0.1, paddingInner = padding, paddingOuter = key === "fx" || key === "fy" ? 0 : padding, ...options }) {
  return maybeRound(band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter), channels, options, key);
}
function maybeRound(scale2, channels, options, key) {
  let { round } = options;
  if (round !== void 0)
    scale2.round(round = !!round);
  scale2 = ScaleO(key, scale2, channels, options);
  scale2.round = round;
  return scale2;
}
function inferDomain2(channels, interval2, key) {
  const values2 = new InternSet();
  for (const { value, domain } of channels) {
    if (domain !== void 0)
      return domain();
    if (value === void 0)
      continue;
    for (const v of value)
      values2.add(v);
  }
  if (interval2 !== void 0) {
    const [min3, max4] = extent(values2).map(interval2.floor, interval2);
    return interval2.range(min3, interval2.offset(max4));
  }
  if (values2.size > 1e4 && registry.get(key) === position)
    throw new Error("implicit ordinal position domain has more than 10,000 values");
  return sort(values2, ascendingDefined);
}
function inferHint(channels, key) {
  let value;
  for (const { hint } of channels) {
    const candidate = hint?.[key];
    if (candidate === void 0)
      continue;
    if (value === void 0)
      value = candidate;
    else if (value !== candidate)
      return;
  }
  return value;
}
function inferSymbolHint(channels) {
  return {
    fill: inferHint(channels, "fill"),
    stroke: inferHint(channels, "stroke")
  };
}
function inferSymbolRange(hint) {
  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
}

// node_modules/@observablehq/plot/dist/scales.js
function Scales(channelsByScale, { inset: globalInset = 0, insetTop: globalInsetTop = globalInset, insetRight: globalInsetRight = globalInset, insetBottom: globalInsetBottom = globalInset, insetLeft: globalInsetLeft = globalInset, round, nice, clamp, zero, align, padding, ...options } = {}) {
  const scales = {};
  for (const [key, channels] of channelsByScale) {
    const scaleOptions = options[key];
    const scale2 = Scale(key, channels, {
      round: registry.get(key) === position ? round : void 0,
      nice,
      clamp,
      zero,
      align,
      padding,
      ...scaleOptions
    });
    if (scale2) {
      let {
        percent,
        transform: transform2,
        inset,
        insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
        insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
        insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
        insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
      } = scaleOptions || {};
      if (transform2 == null)
        transform2 = void 0;
      else if (typeof transform2 !== "function")
        throw new Error("invalid scale transform; not a function");
      scale2.percent = !!percent;
      scale2.transform = transform2;
      if (key === "x" || key === "fx") {
        scale2.insetLeft = +insetLeft;
        scale2.insetRight = +insetRight;
      } else if (key === "y" || key === "fy") {
        scale2.insetTop = +insetTop;
        scale2.insetBottom = +insetBottom;
      }
      scales[key] = scale2;
    }
  }
  return scales;
}
function ScaleFunctions(scales) {
  return Object.fromEntries(Object.entries(scales).map(([name, { scale: scale2 }]) => [name, scale2]));
}
function autoScaleRange({ x: x2, y: y2, fx, fy }, dimensions) {
  if (fx)
    autoScaleRangeX(fx, dimensions);
  if (fy)
    autoScaleRangeY(fy, dimensions);
  if (x2)
    autoScaleRangeX(x2, fx ? { width: fx.scale.bandwidth() } : dimensions);
  if (y2)
    autoScaleRangeY(y2, fy ? { height: fy.scale.bandwidth() } : dimensions);
}
function autoScaleRangeX(scale2, dimensions) {
  if (scale2.range === void 0) {
    const { insetLeft, insetRight } = scale2;
    const { width, marginLeft = 0, marginRight = 0 } = dimensions;
    const left2 = marginLeft + insetLeft;
    const right2 = width - marginRight - insetRight;
    scale2.range = [left2, Math.max(left2, right2)];
    if (!isOrdinalScale(scale2))
      scale2.range = piecewiseRange(scale2);
    scale2.scale.range(scale2.range);
  }
  autoScaleRound(scale2);
}
function autoScaleRangeY(scale2, dimensions) {
  if (scale2.range === void 0) {
    const { insetTop, insetBottom } = scale2;
    const { height, marginTop = 0, marginBottom = 0 } = dimensions;
    const top2 = marginTop + insetTop;
    const bottom2 = height - marginBottom - insetBottom;
    scale2.range = [Math.max(top2, bottom2), top2];
    if (!isOrdinalScale(scale2))
      scale2.range = piecewiseRange(scale2);
    else
      scale2.range.reverse();
    scale2.scale.range(scale2.range);
  }
  autoScaleRound(scale2);
}
function autoScaleRound(scale2) {
  if (scale2.round === void 0 && isBandScale(scale2) && roundError(scale2) <= 30) {
    scale2.scale.round(true);
  }
}
function roundError({ scale: scale2 }) {
  const n = scale2.domain().length;
  const [start2, stop] = scale2.range();
  const paddingInner = scale2.paddingInner ? scale2.paddingInner() : 1;
  const paddingOuter = scale2.paddingOuter ? scale2.paddingOuter() : scale2.padding();
  const m = n - paddingInner;
  const step = Math.abs(stop - start2) / Math.max(1, m + paddingOuter * 2);
  return (step - Math.floor(step)) * m;
}
function piecewiseRange(scale2) {
  const length2 = scale2.scale.domain().length + isThresholdScale(scale2);
  if (!(length2 > 2))
    return scale2.range;
  const [start2, end] = scale2.range;
  return Array.from({ length: length2 }, (_, i) => start2 + i / (length2 - 1) * (end - start2));
}
function normalizeScale(key, scale2, hint) {
  return Scale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale2 });
}
function Scale(key, channels = [], options = {}) {
  const type2 = inferScaleType(key, channels, options);
  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type: type2 })) {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isTemporal))
      warn(`Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(type2)}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(type2)}".`);
    else if (values2.some(isTemporalString))
      warn(`Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(type2)}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(type2)}".`);
    else if (values2.some(isNumericString))
      warn(`Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(type2)}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(type2)}".`);
  }
  options.type = type2;
  switch (type2) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      options = coerceType(channels, options, coerceNumbers);
      break;
    case "identity":
      switch (registry.get(key)) {
        case position:
          options = coerceType(channels, options, coerceNumbers);
          break;
        case symbol:
          options = coerceType(channels, options, coerceSymbols);
          break;
      }
      break;
    case "utc":
    case "time":
      options = coerceType(channels, options, coerceDates);
      break;
  }
  switch (type2) {
    case "diverging":
      return ScaleDiverging(key, channels, options);
    case "diverging-sqrt":
      return ScaleDivergingSqrt(key, channels, options);
    case "diverging-pow":
      return ScaleDivergingPow(key, channels, options);
    case "diverging-log":
      return ScaleDivergingLog(key, channels, options);
    case "diverging-symlog":
      return ScaleDivergingSymlog(key, channels, options);
    case "categorical":
    case "ordinal":
    case ordinalImplicit:
      return ScaleOrdinal(key, channels, options);
    case "cyclical":
    case "sequential":
    case "linear":
      return ScaleLinear(key, channels, options);
    case "sqrt":
      return ScaleSqrt(key, channels, options);
    case "threshold":
      return ScaleThreshold(key, channels, options);
    case "quantile":
      return ScaleQuantile(key, channels, options);
    case "quantize":
      return ScaleQuantize(key, channels, options);
    case "pow":
      return ScalePow(key, channels, options);
    case "log":
      return ScaleLog(key, channels, options);
    case "symlog":
      return ScaleSymlog(key, channels, options);
    case "utc":
      return ScaleUtc(key, channels, options);
    case "time":
      return ScaleTime(key, channels, options);
    case "point":
      return ScalePoint(key, channels, options);
    case "band":
      return ScaleBand(key, channels, options);
    case "identity":
      return registry.get(key) === position ? ScaleIdentity() : { type: "identity" };
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${type2}`);
  }
}
function formatScaleType(type2) {
  return typeof type2 === "symbol" ? type2.description : type2;
}
function inferScaleType(key, channels, { type: type2, domain, range: range3, scheme: scheme28, pivot }) {
  if (key === "fx" || key === "fy")
    return "band";
  for (const { type: t } of channels) {
    if (t === void 0)
      continue;
    else if (type2 === void 0)
      type2 = t;
    else if (type2 !== t)
      throw new Error(`scale incompatible with channel: ${type2} !== ${t}`);
  }
  if (type2 !== void 0)
    return type2;
  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))
    return;
  const kind = registry.get(key);
  if (kind === color2 && range3 === void 0 && scheme28 === void 0 && isAll(domain, channels, isColor))
    return "identity";
  if (kind === symbol && range3 === void 0 && isAll(domain, channels, isSymbol))
    return "identity";
  if (kind === radius)
    return "sqrt";
  if (kind === opacity || kind === length)
    return "linear";
  if (kind === symbol)
    return "ordinal";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(kind);
  if (domain !== void 0) {
    if (isOrdinal(domain))
      return asOrdinalType(kind);
    if (isTemporal(domain))
      return "utc";
    if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))
      return "diverging";
    return "linear";
  }
  const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
  if (values2.some(isOrdinal))
    return asOrdinalType(kind);
  if (values2.some(isTemporal))
    return "utc";
  if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))
    return "diverging";
  return "linear";
}
function asOrdinalType(kind) {
  switch (kind) {
    case position:
      return "point";
    case color2:
      return ordinalImplicit;
    default:
      return "ordinal";
  }
}
function isAll(domain, channels, is) {
  return domain !== void 0 ? isFirst(domain, is) && isEvery(domain, is) : channels.some(({ value }) => value !== void 0 && isFirst(value, is)) && channels.every(({ value }) => value === void 0 || isEvery(value, is));
}
function isTemporalScale({ type: type2 }) {
  return type2 === "time" || type2 === "utc";
}
function isOrdinalScale({ type: type2 }) {
  return type2 === "ordinal" || type2 === "point" || type2 === "band" || type2 === ordinalImplicit;
}
function isThresholdScale({ type: type2 }) {
  return type2 === "threshold";
}
function isBandScale({ type: type2 }) {
  return type2 === "point" || type2 === "band";
}
function scaleOrder({ range: range3, domain = range3 }) {
  return Math.sign(order(domain)) * Math.sign(order(range3));
}
function isCollapsed(scale2) {
  if (scale2 === void 0)
    return true;
  const domain = scale2.domain();
  const value = scale2(domain[0]);
  for (let i = 1, n = domain.length; i < n; ++i) {
    if (scale2(domain[i]) - value) {
      return false;
    }
  }
  return true;
}
function coerceType(channels, { domain, ...options }, coerceValues) {
  for (const c3 of channels) {
    if (c3.value !== void 0) {
      c3.value = coerceValues(c3.value);
    }
  }
  return {
    domain: domain === void 0 ? domain : coerceValues(domain),
    ...options
  };
}
function coerceSymbols(values2) {
  return map(values2, maybeSymbol);
}
function coerceDates(values2) {
  return map(values2, coerceDate);
}
function coerceNumbers(values2) {
  return isTypedArray(values2) ? values2 : map(values2, coerceNumber, Float64Array);
}
function coerceNumber(x2) {
  return x2 == null ? NaN : +x2;
}
function coerceDate(x2) {
  return x2 instanceof Date && !isNaN(x2) ? x2 : typeof x2 === "string" ? parse(x2) : x2 == null || isNaN(x2 = +x2) ? void 0 : new Date(x2);
}
function scale(options = {}) {
  let scale2;
  for (const key in options) {
    if (!registry.has(key))
      continue;
    if (!isScaleOptions(options[key]))
      continue;
    if (scale2 !== void 0)
      throw new Error("ambiguous scale definition; multiple scales found");
    scale2 = exposeScale(normalizeScale(key, options[key]));
  }
  if (scale2 === void 0)
    throw new Error("invalid scale definition; no scale found");
  return scale2;
}
function exposeScales(scaleDescriptors) {
  return (key) => {
    if (!registry.has(key = `${key}`))
      throw new Error(`unknown scale: ${key}`);
    return key in scaleDescriptors ? exposeScale(scaleDescriptors[key]) : void 0;
  };
}
function exposeScale({ scale: scale2, type: type2, domain, range: range3, label, interpolate, interval: interval2, transform: transform2, percent, pivot }) {
  if (type2 === "identity")
    return { type: "identity", apply: (d) => d, invert: (d) => d };
  const unknown = scale2.unknown ? scale2.unknown() : void 0;
  return {
    type: type2,
    domain: slice3(domain),
    ...range3 !== void 0 && { range: slice3(range3) },
    ...transform2 !== void 0 && { transform: transform2 },
    ...percent && { percent },
    ...label !== void 0 && { label },
    ...unknown !== void 0 && { unknown },
    ...interval2 !== void 0 && { interval: interval2 },
    ...interpolate !== void 0 && { interpolate },
    ...scale2.clamp && { clamp: scale2.clamp() },
    ...pivot !== void 0 && { pivot, symmetric: false },
    ...scale2.base && { base: scale2.base() },
    ...scale2.exponent && { exponent: scale2.exponent() },
    ...scale2.constant && { constant: scale2.constant() },
    ...scale2.align && { align: scale2.align(), round: scale2.round() },
    ...scale2.padding && (scale2.paddingInner ? { paddingInner: scale2.paddingInner(), paddingOuter: scale2.paddingOuter() } : { padding: scale2.padding() }),
    ...scale2.bandwidth && { bandwidth: scale2.bandwidth(), step: scale2.step() },
    apply: (t) => scale2(t),
    ...scale2.invert && { invert: (t) => scale2.invert(t) }
  };
}

// node_modules/@observablehq/plot/dist/axes.js
function Axes({ x: xScale, y: yScale, fx: fxScale, fy: fyScale }, { x: x2 = {}, y: y2 = {}, fx = {}, fy = {}, axis: axis2 = true, grid, line: line2, label, facet: { axis: facetAxis = axis2, grid: facetGrid, label: facetLabel = label } = {} } = {}) {
  let { axis: xAxis = axis2 } = x2;
  let { axis: yAxis = axis2 } = y2;
  let { axis: fxAxis = facetAxis } = fx;
  let { axis: fyAxis = facetAxis } = fy;
  if (!xScale)
    xAxis = null;
  else if (xAxis === true)
    xAxis = "bottom";
  if (!yScale)
    yAxis = null;
  else if (yAxis === true)
    yAxis = "left";
  if (!fxScale)
    fxAxis = null;
  else if (fxAxis === true)
    fxAxis = xAxis === "bottom" ? "top" : "bottom";
  if (!fyScale)
    fyAxis = null;
  else if (fyAxis === true)
    fyAxis = yAxis === "left" ? "right" : "left";
  return {
    ...xAxis && { x: new AxisX({ grid, line: line2, label, fontVariant: inferFontVariant(xScale), ...x2, axis: xAxis }) },
    ...yAxis && { y: new AxisY({ grid, line: line2, label, fontVariant: inferFontVariant(yScale), ...y2, axis: yAxis }) },
    ...fxAxis && {
      fx: new AxisX({
        name: "fx",
        grid: facetGrid,
        label: facetLabel,
        fontVariant: inferFontVariant(fxScale),
        ...fx,
        axis: fxAxis
      })
    },
    ...fyAxis && {
      fy: new AxisY({
        name: "fy",
        grid: facetGrid,
        label: facetLabel,
        fontVariant: inferFontVariant(fyScale),
        ...fy,
        axis: fyAxis
      })
    }
  };
}
function autoAxisTicks({ x: x2, y: y2, fx, fy }, { x: xAxis, y: yAxis, fx: fxAxis, fy: fyAxis }) {
  if (fxAxis)
    autoAxisTicksK(fx, fxAxis, 80);
  if (fyAxis)
    autoAxisTicksK(fy, fyAxis, 35);
  if (xAxis)
    autoAxisTicksK(x2, xAxis, 80);
  if (yAxis)
    autoAxisTicksK(y2, yAxis, 35);
}
function autoAxisTicksK(scale2, axis2, k) {
  if (axis2.ticks === void 0) {
    const interval2 = scale2.interval;
    if (interval2 !== void 0) {
      const [min3, max4] = extent(scale2.scale.domain());
      axis2.ticks = interval2.range(interval2.floor(min3), interval2.offset(interval2.floor(max4)));
    } else {
      const [min3, max4] = extent(scale2.scale.range());
      axis2.ticks = (max4 - min3) / k;
    }
  }
  if (axis2.tickFormat === void 0 && isOrdinalScale(scale2)) {
    axis2.tickFormat = formatDefault;
  }
}
function autoScaleLabels(channels, scales, { x: x2, y: y2, fx, fy }, dimensions, options) {
  if (fx) {
    autoAxisLabelsX(fx, scales.fx, channels.get("fx"));
    if (fx.labelOffset === void 0) {
      const { facetMarginTop, facetMarginBottom } = dimensions;
      fx.labelOffset = fx.axis === "top" ? facetMarginTop : facetMarginBottom;
    }
  }
  if (fy) {
    autoAxisLabelsY(fy, fx, scales.fy, channels.get("fy"));
    if (fy.labelOffset === void 0) {
      const { facetMarginLeft, facetMarginRight } = dimensions;
      fy.labelOffset = fy.axis === "left" ? facetMarginLeft : facetMarginRight;
    }
  }
  if (x2) {
    autoAxisLabelsX(x2, scales.x, channels.get("x"));
    if (x2.labelOffset === void 0) {
      const { marginTop, marginBottom, facetMarginTop, facetMarginBottom } = dimensions;
      x2.labelOffset = x2.axis === "top" ? marginTop - facetMarginTop : marginBottom - facetMarginBottom;
    }
  }
  if (y2) {
    autoAxisLabelsY(y2, x2, scales.y, channels.get("y"));
    if (y2.labelOffset === void 0) {
      const { marginRight, marginLeft, facetMarginLeft, facetMarginRight } = dimensions;
      y2.labelOffset = y2.axis === "left" ? marginLeft - facetMarginLeft : marginRight - facetMarginRight;
    }
  }
  for (const [key, type2] of registry) {
    if (type2 !== position && scales[key]) {
      autoScaleLabel(key, scales[key], channels.get(key), options[key]);
    }
  }
}
function autoAxisLabelsX(axis2, scale2, channels) {
  if (axis2.labelAnchor === void 0) {
    axis2.labelAnchor = isOrdinalScale(scale2) ? "center" : scaleOrder(scale2) < 0 ? "left" : "right";
  }
  if (axis2.label === void 0) {
    axis2.label = inferLabel(channels, scale2, axis2, "x");
  }
  scale2.label = axis2.label;
}
function autoAxisLabelsY(axis2, opposite, scale2, channels) {
  if (axis2.labelAnchor === void 0) {
    axis2.labelAnchor = isOrdinalScale(scale2) ? "center" : opposite && opposite.axis === "top" ? "bottom" : "top";
  }
  if (axis2.label === void 0) {
    axis2.label = inferLabel(channels, scale2, axis2, "y");
  }
  scale2.label = axis2.label;
}
function autoScaleLabel(key, scale2, channels, options) {
  if (options) {
    scale2.label = options.label;
  }
  if (scale2.label === void 0) {
    scale2.label = inferLabel(channels, scale2, null, key);
  }
}
function inferLabel(channels = [], scale2, axis2, key) {
  let candidate;
  for (const { label } of channels) {
    if (label === void 0)
      continue;
    if (candidate === void 0)
      candidate = label;
    else if (candidate !== label)
      return;
  }
  if (candidate !== void 0) {
    if (isTemporalScale(scale2) && /^(date|time|year)$/i.test(candidate))
      return;
    if (!isOrdinalScale(scale2)) {
      if (scale2.percent)
        candidate = `${candidate} (%)`;
      if (key === "x" || key === "y") {
        const order2 = scaleOrder(scale2);
        if (order2) {
          if (key === "x" || axis2 && axis2.labelAnchor === "center") {
            candidate = key === "x" === order2 < 0 ? `\u2190 ${candidate}` : `${candidate} \u2192`;
          } else {
            candidate = `${order2 < 0 ? "\u2191 " : "\u2193 "}${candidate}`;
          }
        }
      }
    }
  }
  return candidate;
}
function inferFontVariant(scale2) {
  return isOrdinalScale(scale2) && scale2.interval === void 0 ? void 0 : "tabular-nums";
}

// node_modules/@observablehq/plot/dist/transforms/basic.js
function basic(options = {}, transform2) {
  let { filter: f1, sort: s1, reverse: r1, transform: t1, initializer: i1, ...remainingOptions } = options;
  if (t1 === void 0) {
    if (f1 != null)
      t1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      t1 = composeTransform(t1, sortTransform(s1));
    if (r1)
      t1 = composeTransform(t1, reverseTransform);
  }
  if (transform2 != null && i1 != null)
    throw new Error("transforms cannot be applied after initializers");
  return {
    ...remainingOptions,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    transform: composeTransform(t1, transform2)
  };
}
function initializer(options = {}, initializer2) {
  let { filter: f1, sort: s1, reverse: r1, initializer: i1, ...remainingOptions } = options;
  if (i1 === void 0) {
    if (f1 != null)
      i1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      i1 = composeInitializer(i1, sortTransform(s1));
    if (r1)
      i1 = composeInitializer(i1, reverseTransform);
  }
  return {
    ...remainingOptions,
    initializer: composeInitializer(i1, initializer2)
  };
}
function composeTransform(t1, t2) {
  if (t1 == null)
    return t2 === null ? void 0 : t2;
  if (t2 == null)
    return t1 === null ? void 0 : t1;
  return function(data, facets) {
    ({ data, facets } = t1.call(this, data, facets));
    return t2.call(this, arrayify(data), facets);
  };
}
function composeInitializer(i1, i2) {
  if (i1 == null)
    return i2 === null ? void 0 : i2;
  if (i2 == null)
    return i1 === null ? void 0 : i1;
  return function(data, facets, channels, scales, dimensions) {
    let c1, d1, f1, c22, d2, f2;
    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, scales, dimensions));
    ({ data: d2 = d1, facets: f2 = f1, channels: c22 } = i2.call(this, d1, f1, { ...channels, ...c1 }, scales, dimensions));
    return { data: d2, facets: f2, channels: { ...c1, ...c22 } };
  };
}
function apply(options, t) {
  return (options.initializer != null ? initializer : basic)(options, t);
}
function filter2(test, options) {
  return apply(options, filterTransform(test));
}
function filterTransform(value) {
  return (data, facets) => {
    const V = valueof(data, value);
    return { data, facets: facets.map((I) => I.filter((i) => V[i])) };
  };
}
function reverse2(options) {
  return { ...apply(options, reverseTransform), sort: null };
}
function reverseTransform(data, facets) {
  return { data, facets: facets.map((I) => I.slice().reverse()) };
}
function shuffle2(options = {}) {
  const { seed, ...remainingOptions } = options;
  return { ...apply(remainingOptions, sortValue(seed == null ? Math.random : lcg(seed))), sort: null };
}
function sort2(order2, options) {
  return {
    ...(isOptions(order2) && order2.channel !== void 0 ? initializer : apply)(options, sortTransform(order2)),
    sort: null
  };
}
function sortTransform(value) {
  return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
}
function sortData(compare) {
  return (data, facets) => {
    const compareData = (i, j) => compare(data[i], data[j]);
    return { data, facets: facets.map((I) => I.slice().sort(compareData)) };
  };
}
function sortValue(value) {
  let channel, order2;
  ({ channel, value, order: order2 = ascendingDefined } = { ...maybeValue(value) });
  if (typeof order2 !== "function") {
    switch (`${order2}`.toLowerCase()) {
      case "ascending":
        order2 = ascendingDefined;
        break;
      case "descending":
        order2 = descendingDefined;
        break;
      default:
        throw new Error(`invalid order: ${order2}`);
    }
  }
  return (data, facets, channels) => {
    let V;
    if (channel === void 0) {
      V = valueof(data, value);
    } else {
      if (channels === void 0)
        throw new Error("channel sort requires an initializer");
      V = channels[channel];
      if (!V)
        return {};
      V = V.value;
    }
    const compareValue = (i, j) => order2(V[i], V[j]);
    return { data, facets: facets.map((I) => I.slice().sort(compareValue)) };
  };
}

// node_modules/@observablehq/plot/dist/transforms/group.js
function groupZ2(outputs, options) {
  return groupn(null, null, outputs, options);
}
function groupX(outputs = { y: "count" }, options = {}) {
  const { x: x2 = identity3 } = options;
  if (x2 == null)
    throw new Error("missing channel: x");
  return groupn(x2, null, outputs, options);
}
function groupY(outputs = { x: "count" }, options = {}) {
  const { y: y2 = identity3 } = options;
  if (y2 == null)
    throw new Error("missing channel: y");
  return groupn(null, y2, outputs, options);
}
function group2(outputs = { fill: "count" }, options = {}) {
  let { x: x2, y: y2 } = options;
  [x2, y2] = maybeTuple(x2, y2);
  if (x2 == null)
    throw new Error("missing channel: x");
  if (y2 == null)
    throw new Error("missing channel: y");
  return groupn(x2, y2, outputs, options);
}
function groupn(x2, y2, {
  data: reduceData = reduceIdentity,
  filter: filter3,
  sort: sort3,
  reverse: reverse3,
  ...outputs
} = {}, inputs = {}) {
  outputs = maybeOutputs(outputs, inputs);
  reduceData = maybeReduce(reduceData, identity3);
  sort3 = sort3 == null ? void 0 : maybeOutput("sort", sort3, inputs);
  filter3 = filter3 == null ? void 0 : maybeEvaluator("filter", filter3, inputs);
  const [GX, setGX] = maybeColumn(x2);
  const [GY, setGY] = maybeColumn(y2);
  const {
    z,
    fill,
    stroke,
    x1: x12,
    x2: x22,
    y1: y12,
    y2: y22,
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets) => {
      const X3 = valueof(data, x2);
      const Y3 = valueof(data, y2);
      const Z = valueof(data, z);
      const F = valueof(data, vfill);
      const S = valueof(data, vstroke);
      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });
      const groupFacets = [];
      const groupData = [];
      const GX2 = X3 && setGX([]);
      const GY2 = Y3 && setGY([]);
      const GZ2 = Z && setGZ([]);
      const GF2 = F && setGF([]);
      const GS2 = S && setGS([]);
      let i = 0;
      for (const o of outputs)
        o.initialize(data);
      if (sort3)
        sort3.initialize(data);
      if (filter3)
        filter3.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o of outputs)
          o.scope("facet", facet);
        if (sort3)
          sort3.scope("facet", facet);
        if (filter3)
          filter3.scope("facet", facet);
        for (const [f, I] of maybeGroup(facet, G)) {
          for (const [y3, gg] of maybeGroup(I, Y3)) {
            for (const [x3, g] of maybeGroup(gg, X3)) {
              if (filter3 && !filter3.reduce(g))
                continue;
              groupFacet.push(i++);
              groupData.push(reduceData.reduce(g, data));
              if (X3)
                GX2.push(x3);
              if (Y3)
                GY2.push(y3);
              if (Z)
                GZ2.push(G === Z ? f : Z[g[0]]);
              if (F)
                GF2.push(G === F ? f : F[g[0]]);
              if (S)
                GS2.push(G === S ? f : S[g[0]]);
              for (const o of outputs)
                o.reduce(g);
              if (sort3)
                sort3.reduce(g);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort3, reverse3);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (GX ? { x: GX } : { x1: x12, x2: x22 }),
    ...!hasOutput(outputs, "y") && (GY ? { y: GY } : { y1: y12, y2: y22 }),
    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
  };
}
function hasOutput(outputs, ...names) {
  for (const { name } of outputs) {
    if (names.includes(name)) {
      return true;
    }
  }
  return false;
}
function maybeOutputs(outputs, inputs) {
  const entries = Object.entries(outputs);
  if (inputs.title != null && outputs.title === void 0)
    entries.push(["title", reduceTitle]);
  if (inputs.href != null && outputs.href === void 0)
    entries.push(["href", reduceFirst]);
  return entries.map(([name, reduce]) => {
    return reduce == null ? { name, initialize() {
    }, scope() {
    }, reduce() {
    } } : maybeOutput(name, reduce, inputs);
  });
}
function maybeOutput(name, reduce, inputs) {
  const evaluator = maybeEvaluator(name, reduce, inputs);
  const [output, setOutput] = column(evaluator.label);
  let O;
  return {
    name,
    output,
    initialize(data) {
      evaluator.initialize(data);
      O = setOutput([]);
    },
    scope(scope, I) {
      evaluator.scope(scope, I);
    },
    reduce(I, extent3) {
      O.push(evaluator.reduce(I, extent3));
    }
  };
}
function maybeEvaluator(name, reduce, inputs) {
  const input = maybeInput(name, inputs);
  const reducer = maybeReduce(reduce, input);
  let V, context;
  return {
    label: labelof(reducer === reduceCount ? null : input, reducer.label),
    initialize(data) {
      V = input === void 0 ? data : valueof(data, input);
      if (reducer.scope === "data") {
        context = reducer.reduce(range2(data), V);
      }
    },
    scope(scope, I) {
      if (reducer.scope === scope) {
        context = reducer.reduce(I, V);
      }
    },
    reduce(I, extent3) {
      return reducer.scope == null ? reducer.reduce(I, V, extent3) : reducer.reduce(I, V, context, extent3);
    }
  };
}
function maybeGroup(I, X3) {
  return X3 ? sort(group(I, (i) => X3[i]), first) : [[, I]];
}
function maybeReduce(reduce, value) {
  if (reduce && typeof reduce.reduce === "function")
    return reduce;
  if (typeof reduce === "function")
    return reduceFunction(reduce);
  if (/^p\d{2}$/i.test(reduce))
    return reduceAccessor(percentile(reduce));
  switch (`${reduce}`.toLowerCase()) {
    case "first":
      return reduceFirst;
    case "last":
      return reduceLast;
    case "count":
      return reduceCount;
    case "distinct":
      return reduceDistinct;
    case "sum":
      return value == null ? reduceCount : reduceSum;
    case "proportion":
      return reduceProportion(value, "data");
    case "proportion-facet":
      return reduceProportion(value, "facet");
    case "deviation":
      return reduceAccessor(deviation);
    case "min":
      return reduceAccessor(min);
    case "min-index":
      return reduceAccessor(minIndex);
    case "max":
      return reduceAccessor(max);
    case "max-index":
      return reduceAccessor(maxIndex);
    case "mean":
      return reduceAccessor(mean);
    case "median":
      return reduceAccessor(median);
    case "variance":
      return reduceAccessor(variance);
    case "mode":
      return reduceAccessor(mode);
    case "x":
      return reduceX;
    case "x1":
      return reduceX1;
    case "x2":
      return reduceX2;
    case "y":
      return reduceY;
    case "y1":
      return reduceY1;
    case "y2":
      return reduceY2;
  }
  throw new Error(`invalid reduce: ${reduce}`);
}
function maybeSubgroup(outputs, inputs) {
  for (const name in inputs) {
    const value = inputs[name];
    if (value !== void 0 && !outputs.some((o) => o.name === name)) {
      return value;
    }
  }
}
function maybeSort(facets, sort3, reverse3) {
  if (sort3) {
    const S = sort3.output.transform();
    const compare = (i, j) => ascendingDefined(S[i], S[j]);
    facets.forEach((f) => f.sort(compare));
  }
  if (reverse3) {
    facets.forEach((f) => f.reverse());
  }
}
function reduceFunction(f) {
  return {
    reduce(I, X3, extent3) {
      return f(take(X3, I), extent3);
    }
  };
}
function reduceAccessor(f) {
  return {
    reduce(I, X3) {
      return f(I, (i) => X3[i]);
    }
  };
}
var reduceIdentity = {
  reduce(I, X3) {
    return take(X3, I);
  }
};
var reduceFirst = {
  reduce(I, X3) {
    return X3[I[0]];
  }
};
var reduceTitle = {
  reduce(I, X3) {
    const n = 5;
    const groups2 = sort(rollup(I, (V) => V.length, (i) => X3[i]), second);
    const top2 = groups2.slice(-n).reverse();
    if (top2.length < groups2.length) {
      const bottom2 = groups2.slice(0, 1 - n);
      top2[n - 1] = [`\u2026 ${bottom2.length.toLocaleString("en-US")} more`, sum(bottom2, second)];
    }
    return top2.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
  }
};
var reduceLast = {
  reduce(I, X3) {
    return X3[I[I.length - 1]];
  }
};
var reduceCount = {
  label: "Frequency",
  reduce(I) {
    return I.length;
  }
};
var reduceDistinct = {
  label: "Distinct",
  reduce: (I, X3) => {
    const s = new InternSet();
    for (const i of I)
      s.add(X3[i]);
    return s.size;
  }
};
var reduceSum = reduceAccessor(sum);
function reduceProportion(value, scope) {
  return value == null ? { scope, label: "Frequency", reduce: (I, V, basis = 1) => I.length / basis } : { scope, reduce: (I, V, basis = 1) => sum(I, (i) => V[i]) / basis };
}
function mid2(x12, x2) {
  const m = (+x12 + +x2) / 2;
  return x12 instanceof Date ? new Date(m) : m;
}
var reduceX = {
  reduce(I, X3, { x1: x12, x2 }) {
    return mid2(x12, x2);
  }
};
var reduceY = {
  reduce(I, X3, { y1: y12, y2 }) {
    return mid2(y12, y2);
  }
};
var reduceX1 = {
  reduce(I, X3, { x1: x12 }) {
    return x12;
  }
};
var reduceX2 = {
  reduce(I, X3, { x2 }) {
    return x2;
  }
};
var reduceY1 = {
  reduce(I, X3, { y1: y12 }) {
    return y12;
  }
};
var reduceY2 = {
  reduce(I, X3, { y2 }) {
    return y2;
  }
};

// node_modules/@observablehq/plot/dist/channel.js
function Channel(data, { scale: scale2, type: type2, value, filter: filter3, hint }) {
  return {
    scale: scale2,
    type: type2,
    value: valueof(data, value),
    label: labelof(value),
    filter: filter3,
    hint
  };
}
function Channels(descriptors, data) {
  return Object.fromEntries(Object.entries(descriptors).map(([name, channel]) => {
    return [name, Channel(data, channel)];
  }));
}
function valueObject(channels, scales) {
  return Object.fromEntries(Object.entries(channels).map(([name, { scale: scaleName, value }]) => {
    const scale2 = scales[scaleName];
    return [name, scale2 === void 0 ? value : map(value, scale2)];
  }));
}
function channelDomain(channels, facetChannels, data, options) {
  const { reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;
  for (const x2 in options) {
    if (!registry.has(x2))
      continue;
    let { value: y2, reverse: reverse3 = defaultReverse, reduce = defaultReduce, limit = defaultLimit } = maybeValue(options[x2]);
    if (reverse3 === void 0)
      reverse3 = y2 === "width" || y2 === "height";
    if (reduce == null || reduce === false)
      continue;
    const X3 = findScaleChannel(channels, x2) || facetChannels && findScaleChannel(facetChannels, x2);
    if (!X3)
      throw new Error(`missing channel for scale: ${x2}`);
    const XV = X3.value;
    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
    if (y2 == null) {
      X3.domain = () => {
        let domain = XV;
        if (reverse3)
          domain = domain.slice().reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain;
      };
    } else {
      const YV = y2 === "data" ? data : y2 === "height" ? difference2(channels, "y1", "y2") : y2 === "width" ? difference2(channels, "x1", "x2") : values(channels, y2, y2 === "y" ? "y2" : y2 === "x" ? "x2" : void 0);
      const reducer = maybeReduce(reduce === true ? "max" : reduce, YV);
      X3.domain = () => {
        let domain = rollup(range2(XV), (I) => reducer.reduce(I, YV), (i) => XV[i]);
        domain = sort(domain, reverse3 ? descendingGroup : ascendingGroup);
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain.map(first);
      };
    }
  }
}
function findScaleChannel(channels, scale2) {
  for (const name in channels) {
    const channel = channels[name];
    if (channel.scale === scale2)
      return channel;
  }
}
function difference2(channels, k1, k2) {
  const X12 = values(channels, k1);
  const X22 = values(channels, k2);
  return map(X22, (x2, i) => Math.abs(x2 - X12[i]), Float64Array);
}
function values(channels, name, alias) {
  let channel = channels[name];
  if (!channel && alias !== void 0)
    channel = channels[alias];
  if (channel)
    return channel.value;
  throw new Error(`missing channel: ${name}`);
}
function ascendingGroup([ak, av], [bk, bv]) {
  return ascending(av, bv) || ascending(ak, bk);
}
function descendingGroup([ak, av], [bk, bv]) {
  return descending(av, bv) || ascending(ak, bk);
}

// node_modules/@observablehq/plot/dist/dimensions.js
function Dimensions(scales, { x: { axis: xAxis } = {}, y: { axis: yAxis } = {}, fx: { axis: fxAxis } = {}, fy: { axis: fyAxis } = {} }, { width = 640, height = autoHeight(scales), facet: { margin: facetMargin, marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : fxAxis === "top" ? 30 : 0, marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : fyAxis === "right" ? 40 : 0, marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : fxAxis === "bottom" ? 30 : 0, marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : fyAxis === "left" ? 40 : 0 } = {}, margin, marginTop = margin !== void 0 ? margin : Math.max((xAxis === "top" ? 30 : 0) + facetMarginTop, yAxis || fyAxis ? 20 : 0.5 - offset), marginRight = margin !== void 0 ? margin : Math.max((yAxis === "right" ? 40 : 0) + facetMarginRight, xAxis || fxAxis ? 20 : 0.5 + offset), marginBottom = margin !== void 0 ? margin : Math.max((xAxis === "bottom" ? 30 : 0) + facetMarginBottom, yAxis || fyAxis ? 20 : 0.5 + offset), marginLeft = margin !== void 0 ? margin : Math.max((yAxis === "left" ? 40 : 0) + facetMarginLeft, xAxis || fxAxis ? 20 : 0.5 - offset) } = {}) {
  return {
    width,
    height,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    facetMarginTop,
    facetMarginRight,
    facetMarginBottom,
    facetMarginLeft
  };
}
function autoHeight({ y: y2, fy, fx }) {
  const nfy = fy ? fy.scale.domain().length : 1;
  const ny = y2 ? isOrdinalScale(y2) ? y2.scale.domain().length : Math.max(7, 17 / nfy) : 1;
  return !!(y2 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
}

// node_modules/@observablehq/plot/dist/legends/ramp.js
function legendRamp(color3, options) {
  let { label = color3.label, tickSize = 6, width = 240, height = 44 + tickSize, marginTop = 18, marginRight = 0, marginBottom = 16 + tickSize, marginLeft = 0, style, ticks: ticks2 = (width - marginLeft - marginRight) / 64, tickFormat, fontVariant = inferFontVariant(color3), round = true, className } = options;
  const context = Context(options);
  className = maybeClassName(className);
  if (tickFormat === null)
    tickFormat = () => null;
  const svg2 = create2("svg", context).attr("class", className).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call((svg3) => svg3.append("style").text(`
        .${className} {
          display: block;
          background: white;
          height: auto;
          height: intrinsic;
          max-width: 100%;
          overflow: visible;
        }
        .${className} text {
          white-space: pre;
        }
      `)).call(applyInlineStyles, style);
  let tickAdjust = (g) => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
  let x2;
  const applyRange = round ? (x3, range4) => x3.rangeRound(range4) : (x3, range4) => x3.range(range4);
  const { type: type2, domain, range: range3, interpolate, scale: scale2, pivot } = color3;
  if (interpolate) {
    const interpolator = range3 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range3);
    x2 = applyRange(scale2.copy(), quantize_default(number_default(marginLeft, width - marginRight), Math.min(domain.length + (pivot !== void 0), range3 === void 0 ? Infinity : range3.length)));
    const n = 256;
    const canvas = context.document.createElement("canvas");
    canvas.width = n;
    canvas.height = 1;
    const context2 = canvas.getContext("2d");
    for (let i = 0, j = n - 1; i < n; ++i) {
      context2.fillStyle = interpolator(i / j);
      context2.fillRect(i, 0, 1, 1);
    }
    svg2.append("image").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
  } else if (type2 === "threshold") {
    const thresholds = domain;
    const thresholdFormat = tickFormat === void 0 ? (d) => d : typeof tickFormat === "string" ? format(tickFormat) : tickFormat;
    x2 = applyRange(linear().domain([-1, range3.length - 1]), [marginLeft, width - marginRight]);
    svg2.append("g").selectAll().data(range3).enter().append("rect").attr("x", (d, i) => x2(i - 1)).attr("y", marginTop).attr("width", (d, i) => x2(i) - x2(i - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d) => d);
    ticks2 = map(thresholds, (_, i) => i);
    tickFormat = (i) => thresholdFormat(thresholds[i], i);
  } else {
    x2 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
    svg2.append("g").selectAll().data(domain).enter().append("rect").attr("x", x2).attr("y", marginTop).attr("width", Math.max(0, x2.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale2);
    tickAdjust = () => {
    };
  }
  svg2.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(axisBottom(x2).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat === "string" ? tickFormat : void 0).tickFormat(typeof tickFormat === "function" ? tickFormat : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g) => g.select(".domain").remove());
  if (label !== void 0) {
    svg2.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
  }
  return svg2.node();
}

// node_modules/@observablehq/plot/dist/legends/swatches.js
function maybeScale(scale2, key) {
  if (key == null)
    return key;
  const s = scale2(key);
  if (!s)
    throw new Error(`scale not found: ${key}`);
  return s;
}
function legendSwatches(color3, options) {
  if (!isOrdinalScale(color3) && !isThresholdScale(color3))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);
  return legendItems(color3, options, (selection2, scale2) => selection2.append("svg").attr("fill", scale2.scale).append("rect").attr("width", "100%").attr("height", "100%"), (className) => `.${className}-swatch svg {
        width: var(--swatchWidth);
        height: var(--swatchHeight);
        margin-right: 0.5em;
      }`);
}
function legendSymbols(symbol2, { fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : "none", fillOpacity = 1, stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? "currentColor" : "none", strokeOpacity = 1, strokeWidth = 1.5, r = 4.5, ...options } = {}, scale2) {
  const [vf, cf] = maybeColorChannel(fill);
  const [vs, cs] = maybeColorChannel(stroke);
  const sf = maybeScale(scale2, vf);
  const ss = maybeScale(scale2, vs);
  const size = r * r * Math.PI;
  fillOpacity = maybeNumberChannel(fillOpacity)[1];
  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
  strokeWidth = maybeNumberChannel(strokeWidth)[1];
  return legendItems(symbol2, options, (selection2) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("fill", vf === "color" ? (d) => sf.scale(d) : null).attr("stroke", vs === "color" ? (d) => ss.scale(d) : null).append("path").attr("d", (d) => {
    const p = path_default();
    symbol2.scale(d).draw(p, size);
    return p;
  }), (className) => `.${className}-swatch > svg {
        width: var(--swatchWidth);
        height: var(--swatchHeight);
        margin-right: 0.5em;
        overflow: visible;
        fill: ${cf};
        fill-opacity: ${fillOpacity};
        stroke: ${cs};
        stroke-width: ${strokeWidth}px;
        stroke-opacity: ${strokeOpacity};
      }`);
}
function legendItems(scale2, options = {}, swatch, swatchStyle) {
  let {
    columns,
    tickFormat,
    fontVariant = inferFontVariant(scale2),
    swatchSize = 15,
    swatchWidth = swatchSize,
    swatchHeight = swatchSize,
    marginLeft = 0,
    className,
    style,
    width
  } = options;
  const context = Context(options);
  className = maybeClassName(className);
  tickFormat = maybeAutoTickFormat(tickFormat, scale2.domain);
  const swatches = create2("div", context).attr("class", className).attr("style", `
        --swatchWidth: ${+swatchWidth}px;
        --swatchHeight: ${+swatchHeight}px;
      `);
  let extraStyle;
  if (columns != null) {
    extraStyle = `
      .${className}-swatch {
        display: flex;
        align-items: center;
        break-inside: avoid;
        padding-bottom: 1px;
      }
      .${className}-swatch::before {
        flex-shrink: 0;
      }
      .${className}-label {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
    `;
    swatches.style("columns", columns).selectAll().data(scale2.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale2).call((item) => item.append("div").attr("class", `${className}-label`).attr("title", tickFormat).text(tickFormat));
  } else {
    extraStyle = `
      .${className} {
        display: flex;
        align-items: center;
        min-height: 33px;
        flex-wrap: wrap;
      }
      .${className}-swatch {
        display: inline-flex;
        align-items: center;
        margin-right: 1em;
      }
    `;
    swatches.selectAll().data(scale2.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale2).append(function() {
      return this.ownerDocument.createTextNode(tickFormat.apply(this, arguments));
    });
  }
  return swatches.call((div) => div.insert("style", "*").text(`
        .${className} {
          font-family: system-ui, sans-serif;
          font-size: 10px;
          margin-bottom: 0.5em;${marginLeft === void 0 ? "" : `
          margin-left: ${+marginLeft}px;`}${width === void 0 ? "" : `
          width: ${width}px;`}
        }
        ${swatchStyle(className)}
        ${extraStyle}
      `)).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
}

// node_modules/@observablehq/plot/dist/legends.js
var legendRegistry = /* @__PURE__ */ new Map([
  ["symbol", legendSymbols],
  ["color", legendColor],
  ["opacity", legendOpacity]
]);
function legend(options = {}) {
  for (const [key, value] of legendRegistry) {
    const scale2 = options[key];
    if (isScaleOptions(scale2)) {
      const context = Context(options);
      let hint;
      if (key === "symbol") {
        const { fill, stroke = fill === void 0 && isScaleOptions(options.color) ? "color" : void 0 } = options;
        hint = { fill, stroke };
      }
      return value(normalizeScale(key, scale2, hint), legendOptions(context, scale2, options), (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null);
    }
  }
  throw new Error("unknown legend type; no scale found");
}
function exposeLegends(scales, context, defaults18 = {}) {
  return (key, options) => {
    if (!legendRegistry.has(key))
      throw new Error(`unknown legend type: ${key}`);
    if (!(key in scales))
      return;
    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults18[key], options), (key2) => scales[key2]);
  };
}
function legendOptions(context, { label, ticks: ticks2, tickFormat } = {}, options) {
  return inherit2(options, context, { label, ticks: ticks2, tickFormat });
}
function legendColor(color3, { legend: legend2 = true, ...options }) {
  if (legend2 === true)
    legend2 = color3.type === "ordinal" ? "swatches" : "ramp";
  if (color3.domain === void 0)
    return;
  switch (`${legend2}`.toLowerCase()) {
    case "swatches":
      return legendSwatches(color3, options);
    case "ramp":
      return legendRamp(color3, options);
    default:
      throw new Error(`unknown legend type: ${legend2}`);
  }
}
function legendOpacity({ type: type2, interpolate, ...scale2 }, { legend: legend2 = true, color: color3 = rgb(0, 0, 0), ...options }) {
  if (!interpolate)
    throw new Error(`${type2} opacity scales are not supported`);
  if (legend2 === true)
    legend2 = "ramp";
  if (`${legend2}`.toLowerCase() !== "ramp")
    throw new Error(`${legend2} opacity legends are not supported`);
  return legendColor({ type: type2, ...scale2, interpolate: interpolateOpacity(color3) }, { legend: legend2, ...options });
}
function interpolateOpacity(color3) {
  const { r, g, b } = rgb(color3) || rgb(0, 0, 0);
  return (t) => `rgba(${r},${g},${b},${t})`;
}
function Legends(scales, context, options) {
  const legends = [];
  for (const [key, value] of legendRegistry) {
    const o = options[key];
    if (o?.legend && key in scales) {
      const legend2 = value(scales[key], legendOptions(context, scales[key], o), (key2) => scales[key2]);
      if (legend2 != null)
        legends.push(legend2);
    }
  }
  return legends;
}

// node_modules/@observablehq/plot/dist/plot.js
function plot(options = {}) {
  const { facet, style, caption, ariaLabel, ariaDescription } = options;
  const className = maybeClassName(options.className);
  const marks2 = options.marks === void 0 ? [] : options.marks.flat(Infinity).map(markify);
  const stateByMark = /* @__PURE__ */ new Map();
  const channelsByScale = /* @__PURE__ */ new Map();
  for (const key of registry.keys()) {
    if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
      channelsByScale.set(key, []);
    }
  }
  let facets;
  let facetIndex;
  let facetChannels;
  let facetsIndex;
  let facetsExclude;
  let facetData;
  if (facet !== void 0) {
    const { x: x2, y: y2 } = facet;
    if (x2 != null || y2 != null) {
      facetData = arrayify(facet.data);
      if (facetData == null)
        throw new Error("missing facet data");
      facetChannels = {};
      if (x2 != null) {
        const fx2 = Channel(facetData, { value: x2, scale: "fx" });
        facetChannels.fx = fx2;
        channelsByScale.set("fx", [fx2]);
      }
      if (y2 != null) {
        const fy2 = Channel(facetData, { value: y2, scale: "fy" });
        facetChannels.fy = fy2;
        channelsByScale.set("fy", [fy2]);
      }
      facetIndex = range2(facetData);
      facets = facetGroups(facetIndex, facetChannels);
      facetsIndex = facets.map(second);
    }
  }
  for (const mark of marks2) {
    if (stateByMark.has(mark))
      throw new Error("duplicate mark; each mark must be unique");
    const markFacets = facetsIndex === void 0 ? void 0 : mark.facet === "auto" ? mark.data === facet.data ? facetsIndex : void 0 : mark.facet === "include" ? facetsIndex : mark.facet === "exclude" ? facetsExclude || (facetsExclude = facetsIndex.map((f) => Uint32Array.from(difference(facetIndex, f)))) : void 0;
    const { data, facets: facets2, channels } = mark.initialize(markFacets, facetChannels);
    applyScaleTransforms(channels, options);
    stateByMark.set(mark, { data, facets: facets2, channels });
    if (facetIndex?.length > 1 && mark.facet === "auto" && mark.data !== facet.data && arrayify(mark.data)?.length === facetData.length) {
      warn(`Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`);
    }
  }
  const scaleDescriptors = Scales(addScaleChannels(channelsByScale, stateByMark), options);
  const scales = ScaleFunctions(scaleDescriptors);
  const axes = Axes(scaleDescriptors, options);
  const dimensions = Dimensions(scaleDescriptors, axes, options);
  const context = Context(options);
  autoScaleRange(scaleDescriptors, dimensions);
  autoAxisTicks(scaleDescriptors, axes);
  const { fx, fy } = scales;
  const fyMargins = fy && { marginTop: 0, marginBottom: 0, height: fy.bandwidth() };
  const fxMargins = fx && { marginRight: 0, marginLeft: 0, width: fx.bandwidth() };
  const subdimensions = { ...dimensions, ...fxMargins, ...fyMargins };
  const newByScale = /* @__PURE__ */ new Set();
  for (const [mark, state] of stateByMark) {
    if (mark.initializer != null) {
      const { facets: facets2, channels } = mark.initializer(state.data, state.facets, state.channels, scales, subdimensions);
      if (facets2 !== void 0)
        state.facets = facets2;
      if (channels !== void 0) {
        inferChannelScale(channels, mark);
        applyScaleTransforms(channels, options);
        Object.assign(state.channels, channels);
        for (const { scale: scale2 } of Object.values(channels))
          if (scale2 != null)
            newByScale.add(scale2);
      }
    }
  }
  if (newByScale.size) {
    for (const key of newByScale)
      if (registry.get(key) === position)
        throw new Error(`initializers cannot declare position scales: ${key}`);
    const newScaleDescriptors = Scales(addScaleChannels(/* @__PURE__ */ new Map(), stateByMark, (key) => newByScale.has(key)), options);
    const newScales = ScaleFunctions(newScaleDescriptors);
    Object.assign(scaleDescriptors, newScaleDescriptors);
    Object.assign(scales, newScales);
  }
  autoScaleLabels(channelsByScale, scaleDescriptors, axes, dimensions, options);
  for (const state of stateByMark.values()) {
    state.values = valueObject(state.channels, scales);
  }
  const { width, height } = dimensions;
  const svg2 = create2("svg", context).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call((svg3) => svg3.append("style").text(`
        .${className} {
          display: block;
          background: white;
          height: auto;
          height: intrinsic;
          max-width: 100%;
        }
        .${className} text,
        .${className} tspan {
          white-space: pre;
        }
      `)).call(applyInlineStyles, style).node();
  const axisY = axes[facets !== void 0 && fy ? "fy" : "y"];
  const axisX = axes[facets !== void 0 && fx ? "fx" : "x"];
  if (axisY)
    svg2.appendChild(axisY.render(null, scales, dimensions, context));
  if (axisX)
    svg2.appendChild(axisX.render(null, scales, dimensions, context));
  if (facets !== void 0) {
    const fyDomain = fy && fy.domain();
    const fxDomain = fx && fx.domain();
    const indexByFacet = facetMap(facetChannels);
    facets.forEach(([key], i) => indexByFacet.set(key, i));
    const selection2 = select_default2(svg2);
    if (fy && axes.y) {
      const axis1 = axes.y, axis2 = nolabel(axis1);
      const j = axis1.labelAnchor === "bottom" ? fyDomain.length - 1 : axis1.labelAnchor === "center" ? fyDomain.length >> 1 : 0;
      selection2.selectAll().data(fyDomain).enter().append((ky, i) => (i === j ? axis1 : axis2).render(fx && where(fxDomain, (kx) => indexByFacet.has([kx, ky])), scales, { ...dimensions, ...fyMargins, offsetTop: fy(ky) }, context));
    }
    if (fx && axes.x) {
      const axis1 = axes.x, axis2 = nolabel(axis1);
      const j = axis1.labelAnchor === "right" ? fxDomain.length - 1 : axis1.labelAnchor === "center" ? fxDomain.length >> 1 : 0;
      const { marginLeft, marginRight } = dimensions;
      selection2.selectAll().data(fxDomain).enter().append((kx, i) => (i === j ? axis1 : axis2).render(fy && where(fyDomain, (ky) => indexByFacet.has([kx, ky])), scales, {
        ...dimensions,
        ...fxMargins,
        labelMarginLeft: marginLeft,
        labelMarginRight: marginRight,
        offsetLeft: fx(kx)
      }, context));
    }
    selection2.selectAll().data(facetKeys(scales).filter(indexByFacet.has, indexByFacet)).enter().append("g").attr("aria-label", "facet").attr("transform", facetTranslate(fx, fy)).each(function(key) {
      const j = indexByFacet.get(key);
      for (const [mark, { channels, values: values2, facets: facets2 }] of stateByMark) {
        const facet2 = facets2 ? mark.filter(facets2[j] ?? facets2[0], channels, values2) : null;
        const node = mark.render(facet2, scales, values2, subdimensions, context);
        if (node != null)
          this.appendChild(node);
      }
    });
  } else {
    for (const [mark, { channels, values: values2, facets: facets2 }] of stateByMark) {
      const facet2 = facets2 ? mark.filter(facets2[0], channels, values2) : null;
      const node = mark.render(facet2, scales, values2, dimensions, context);
      if (node != null)
        svg2.appendChild(node);
    }
  }
  let figure = svg2;
  const legends = Legends(scaleDescriptors, context, options);
  if (caption != null || legends.length > 0) {
    const { document: document2 } = context;
    figure = document2.createElement("figure");
    figure.style.maxWidth = "initial";
    for (const legend2 of legends)
      figure.appendChild(legend2);
    figure.appendChild(svg2);
    if (caption != null) {
      const figcaption = document2.createElement("figcaption");
      figcaption.appendChild(caption instanceof Node ? caption : document2.createTextNode(caption));
      figure.appendChild(figcaption);
    }
  }
  figure.scale = exposeScales(scaleDescriptors);
  figure.legend = exposeLegends(scaleDescriptors, context, options);
  const w = consumeWarnings();
  if (w > 0) {
    select_default2(svg2).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w.toLocaleString("en-US")} warning${w === 1 ? "" : "s"}. Please check the console.`);
  }
  return figure;
}
var Mark = class {
  constructor(data, channels = {}, options = {}, defaults18) {
    const { facet = "auto", sort: sort3, dx, dy, clip, channels: extraChannels } = options;
    this.data = data;
    this.sort = isDomainSort(sort3) ? sort3 : null;
    this.initializer = initializer(options).initializer;
    this.transform = this.initializer ? options.transform : basic(options).transform;
    this.facet = facet == null || facet === false ? null : keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude"]);
    channels = maybeNamed(channels);
    if (extraChannels !== void 0)
      channels = { ...maybeNamed(extraChannels), ...channels };
    if (defaults18 !== void 0)
      channels = { ...styles(this, options, defaults18), ...channels };
    this.channels = Object.fromEntries(Object.entries(channels).filter(([name, { value, optional: optional2 }]) => {
      if (value != null)
        return true;
      if (optional2)
        return false;
      throw new Error(`missing channel value: ${name}`);
    }));
    this.dx = +dx || 0;
    this.dy = +dy || 0;
    this.clip = maybeClip(clip);
  }
  initialize(facets, facetChannels) {
    let data = arrayify(this.data);
    if (facets === void 0 && data != null)
      facets = [range2(data)];
    if (this.transform != null)
      ({ facets, data } = this.transform(data, facets)), data = arrayify(data);
    const channels = Channels(this.channels, data);
    if (this.sort != null)
      channelDomain(channels, facetChannels, data, this.sort);
    return { data, facets, channels };
  }
  filter(index, channels, values2) {
    for (const name in channels) {
      const { filter: filter3 = defined } = channels[name];
      if (filter3 !== null) {
        const value = values2[name];
        index = index.filter((i) => filter3(value[i]));
      }
    }
    return index;
  }
  plot({ marks: marks2 = [], ...options } = {}) {
    return plot({ ...options, marks: [...marks2, this] });
  }
};
function marks(...marks2) {
  marks2.plot = Mark.prototype.plot;
  return marks2;
}
function markify(mark) {
  return typeof mark?.render === "function" ? mark : new Render(mark);
}
var Render = class extends Mark {
  constructor(render) {
    super();
    if (render == null)
      return;
    if (typeof render !== "function")
      throw new TypeError("invalid mark; missing render function");
    this.render = render;
  }
  render() {
  }
};
function applyScaleTransforms(channels, options) {
  for (const name in channels) {
    const channel = channels[name];
    const { scale: scale2 } = channel;
    if (scale2 != null) {
      const { percent, interval: interval2, transform: transform2 = percent ? (x2) => x2 * 100 : maybeInterval(interval2)?.floor } = options[scale2] || {};
      if (transform2 != null)
        channel.value = map(channel.value, transform2);
    }
  }
  return channels;
}
function inferChannelScale(channels) {
  for (const name in channels) {
    const channel = channels[name];
    let { scale: scale2 } = channel;
    if (scale2 === true) {
      switch (name) {
        case "fill":
        case "stroke":
          scale2 = "color";
          break;
        case "fillOpacity":
        case "strokeOpacity":
        case "opacity":
          scale2 = "opacity";
          break;
        default:
          scale2 = registry.has(name) ? name : null;
          break;
      }
      channel.scale = scale2;
    }
  }
}
function addScaleChannels(channelsByScale, stateByMark, filter3 = yes) {
  for (const { channels } of stateByMark.values()) {
    for (const name in channels) {
      const channel = channels[name];
      const { scale: scale2 } = channel;
      if (scale2 != null && filter3(scale2)) {
        const channels2 = channelsByScale.get(scale2);
        if (channels2 !== void 0)
          channels2.push(channel);
        else
          channelsByScale.set(scale2, [channel]);
      }
    }
  }
  return channelsByScale;
}
function nolabel(axis2) {
  return axis2 === void 0 || axis2.label === void 0 ? axis2 : Object.assign(Object.create(axis2), { label: void 0 });
}
function facetKeys({ fx, fy }) {
  return fx && fy ? cross(fx.domain(), fy.domain()) : fx ? fx.domain() : fy.domain();
}
function facetGroups(index, { fx, fy }) {
  return fx && fy ? facetGroup2(index, fx, fy) : fx ? facetGroup1(index, fx) : facetGroup1(index, fy);
}
function facetGroup1(index, { value: F }) {
  return groups(index, (i) => F[i]);
}
function facetGroup2(index, { value: FX }, { value: FY }) {
  return groups(index, (i) => FX[i], (i) => FY[i]).flatMap(([x2, xgroup]) => xgroup.map(([y2, ygroup]) => [[x2, y2], ygroup]));
}
function facetTranslate(fx, fy) {
  return fx && fy ? ([kx, ky]) => `translate(${fx(kx)},${fy(ky)})` : fx ? (kx) => `translate(${fx(kx)},0)` : (ky) => `translate(0,${fy(ky)})`;
}
function facetMap({ fx, fy }) {
  return new (fx && fy ? FacetMap2 : FacetMap)();
}
var FacetMap = class {
  constructor() {
    this._ = new InternMap();
  }
  has(key) {
    return this._.has(key);
  }
  get(key) {
    return this._.get(key);
  }
  set(key, value) {
    return this._.set(key, value), this;
  }
};
var FacetMap2 = class extends FacetMap {
  has([key1, key2]) {
    const map3 = super.get(key1);
    return map3 ? map3.has(key2) : false;
  }
  get([key1, key2]) {
    const map3 = super.get(key1);
    return map3 && map3.get(key2);
  }
  set([key1, key2], value) {
    const map3 = super.get(key1);
    if (map3)
      map3.set(key2, value);
    else
      super.set(key1, new InternMap([[key2, value]]));
    return this;
  }
};

// node_modules/@observablehq/plot/dist/curve.js
var curves = /* @__PURE__ */ new Map([
  ["basis", basis_default],
  ["basis-closed", basisClosed_default],
  ["basis-open", basisOpen_default],
  ["bundle", bundle_default],
  ["bump-x", bumpX],
  ["bump-y", bumpY],
  ["cardinal", cardinal_default],
  ["cardinal-closed", cardinalClosed_default],
  ["cardinal-open", cardinalOpen_default],
  ["catmull-rom", catmullRom_default],
  ["catmull-rom-closed", catmullRomClosed_default],
  ["catmull-rom-open", catmullRomOpen_default],
  ["linear", linear_default],
  ["linear-closed", linearClosed_default],
  ["monotone-x", monotoneX],
  ["monotone-y", monotoneY],
  ["natural", natural_default],
  ["step", step_default],
  ["step-after", stepAfter],
  ["step-before", stepBefore]
]);
function Curve(curve = linear_default, tension) {
  if (typeof curve === "function")
    return curve;
  const c3 = curves.get(`${curve}`.toLowerCase());
  if (!c3)
    throw new Error(`unknown curve: ${curve}`);
  if (tension !== void 0) {
    if ("beta" in c3) {
      return c3.beta(tension);
    } else if ("tension" in c3) {
      return c3.tension(tension);
    } else if ("alpha" in c3) {
      return c3.alpha(tension);
    }
  }
  return c3;
}

// node_modules/@observablehq/plot/dist/transforms/bin.js
function binX(outputs = { y: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x2, y: y2 } = options;
  return binn(maybeBinValue(x2, options, identity3), null, null, y2, outputs, maybeInsetX(options));
}
function binY(outputs = { x: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x2, y: y2 } = options;
  return binn(null, maybeBinValue(y2, options, identity3), x2, null, outputs, maybeInsetY(options));
}
function bin2(outputs = { fill: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x2, y: y2 } = maybeBinValueTuple(options);
  return binn(x2, y2, null, null, outputs, maybeInsetX(maybeInsetY(options)));
}
function maybeDenseInterval(bin3, k, options = {}) {
  return options?.interval == null ? options : bin3({ [k]: options?.reduce === void 0 ? reduceFirst : options.reduce, filter: null }, options);
}
function maybeDenseIntervalX(options) {
  return maybeDenseInterval(binX, "y", options);
}
function maybeDenseIntervalY(options) {
  return maybeDenseInterval(binY, "x", options);
}
function binn(bx, by, gx, gy, {
  data: reduceData = reduceIdentity,
  filter: filter3 = reduceCount,
  sort: sort3,
  reverse: reverse3,
  ...outputs
} = {}, inputs = {}) {
  bx = maybeBin(bx);
  by = maybeBin(by);
  outputs = maybeOutputs(outputs, inputs);
  reduceData = maybeReduce(reduceData, identity3);
  sort3 = sort3 == null ? void 0 : maybeOutput("sort", sort3, inputs);
  filter3 = filter3 == null ? void 0 : maybeEvaluator("filter", filter3, inputs);
  if (gx != null && hasOutput(outputs, "x", "x1", "x2"))
    gx = null;
  if (gy != null && hasOutput(outputs, "y", "y1", "y2"))
    gy = null;
  const [BX1, setBX1] = maybeColumn(bx);
  const [BX2, setBX2] = maybeColumn(bx);
  const [BY1, setBY1] = maybeColumn(by);
  const [BY2, setBY2] = maybeColumn(by);
  const [k, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
  const [GK, setGK] = maybeColumn(k);
  const {
    x: x2,
    y: y2,
    z,
    fill,
    stroke,
    x1: x12,
    x2: x22,
    y1: y12,
    y2: y22,
    domain,
    cumulative,
    thresholds,
    interval: interval2,
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets) => {
      const K = valueof(data, k);
      const Z = valueof(data, z);
      const F = valueof(data, vfill);
      const S = valueof(data, vstroke);
      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });
      const groupFacets = [];
      const groupData = [];
      const GK2 = K && setGK([]);
      const GZ2 = Z && setGZ([]);
      const GF2 = F && setGF([]);
      const GS2 = S && setGS([]);
      const BX = bx ? bx(data) : [[, , (I) => I]];
      const BY = by ? by(data) : [[, , (I) => I]];
      const BX12 = bx && setBX1([]);
      const BX22 = bx && setBX2([]);
      const BY12 = by && setBY1([]);
      const BY22 = by && setBY2([]);
      let i = 0;
      for (const o of outputs)
        o.initialize(data);
      if (sort3)
        sort3.initialize(data);
      if (filter3)
        filter3.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o of outputs)
          o.scope("facet", facet);
        if (sort3)
          sort3.scope("facet", facet);
        if (filter3)
          filter3.scope("facet", facet);
        for (const [f, I] of maybeGroup(facet, G)) {
          for (const [k2, g] of maybeGroup(I, K)) {
            for (const [x13, x23, fx] of BX) {
              const bb = fx(g);
              for (const [y13, y23, fy] of BY) {
                const extent3 = { x1: x13, x2: x23, y1: y13, y2: y23 };
                const b = fy(bb);
                if (filter3 && !filter3.reduce(b, extent3))
                  continue;
                groupFacet.push(i++);
                groupData.push(reduceData.reduce(b, data, extent3));
                if (K)
                  GK2.push(k2);
                if (Z)
                  GZ2.push(G === Z ? f : Z[b[0]]);
                if (F)
                  GF2.push(G === F ? f : F[b[0]]);
                if (S)
                  GS2.push(G === S ? f : S[b[0]]);
                if (BX12)
                  BX12.push(x13), BX22.push(x23);
                if (BY12)
                  BY12.push(y13), BY22.push(y23);
                for (const o of outputs)
                  o.reduce(b, extent3);
                if (sort3)
                  sort3.reduce(b);
              }
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort3, reverse3);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x2, x1: x12, x2: x22 }),
    ...!hasOutput(outputs, "y") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y2, y1: y12, y2: y22 }),
    ...GK && { [gk]: GK },
    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
  };
}
function mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {
  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];
}
function maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {
  value = { ...maybeValue(value) };
  if (value.domain === void 0)
    value.domain = domain;
  if (value.cumulative === void 0)
    value.cumulative = cumulative;
  if (value.thresholds === void 0)
    value.thresholds = thresholds;
  if (value.interval === void 0)
    value.interval = interval2;
  if (value.value === void 0)
    value.value = defaultValue;
  value.thresholds = maybeThresholds(value.thresholds, value.interval);
  return value;
}
function maybeBinValueTuple(options) {
  let { x: x2, y: y2 } = options;
  x2 = maybeBinValue(x2, options);
  y2 = maybeBinValue(y2, options);
  [x2.value, y2.value] = maybeTuple(x2.value, y2.value);
  return { x: x2, y: y2 };
}
function maybeBin(options) {
  if (options == null)
    return;
  const { value, cumulative, domain = extent, thresholds } = options;
  const bin3 = (data) => {
    let V = valueof(data, value, Array);
    const bin4 = bin().value((i) => V[i]);
    if (isTemporal(V) || isTimeThresholds(thresholds)) {
      V = V.map(coerceDate);
      let [min3, max4] = typeof domain === "function" ? domain(V) : domain;
      let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min3, max4) : thresholds;
      if (typeof t === "number")
        t = utcTickInterval(min3, max4, t);
      if (isInterval(t)) {
        if (domain === extent) {
          min3 = t.floor(min3);
          max4 = t.ceil(new Date(+max4 + 1));
        }
        t = t.range(min3, max4);
      }
      bin4.thresholds(t).domain([min3, max4]);
    } else {
      V = V.map(coerceNumber);
      let d = domain;
      let t = thresholds;
      if (isInterval(t)) {
        let [min3, max4] = typeof d === "function" ? d(V) : d;
        if (d === extent) {
          min3 = t.floor(min3);
          max4 = t.offset(t.floor(max4));
          d = [min3, max4];
        }
        t = t.range(min3, max4);
      }
      bin4.thresholds(t).domain(d);
    }
    let bins = bin4(range2(data)).map(binset);
    if (cumulative)
      bins = (cumulative < 0 ? bins.reverse() : bins).map(bincumset);
    return bins.map(binfilter);
  };
  bin3.label = labelof(value);
  return bin3;
}
function maybeThresholds(thresholds, interval2) {
  if (thresholds === void 0) {
    return interval2 === void 0 ? thresholdAuto : maybeRangeInterval(interval2);
  }
  if (typeof thresholds === "string") {
    switch (thresholds.toLowerCase()) {
      case "freedman-diaconis":
        return thresholdFreedmanDiaconis;
      case "scott":
        return thresholdScott;
      case "sturges":
        return thresholdSturges;
      case "auto":
        return thresholdAuto;
    }
    throw new Error(`invalid thresholds: ${thresholds}`);
  }
  return thresholds;
}
function maybeRangeInterval(interval2) {
  interval2 = maybeInterval(interval2);
  if (!isInterval(interval2))
    throw new Error(`invalid interval: ${interval2}`);
  return interval2;
}
function thresholdAuto(values2, min3, max4) {
  return Math.min(200, thresholdScott(values2, min3, max4));
}
function isTimeThresholds(t) {
  return isTimeInterval(t) || isIterable(t) && isTemporal(t);
}
function isTimeInterval(t) {
  return isInterval(t) && typeof t === "function" && t() instanceof Date;
}
function isInterval(t) {
  return t ? typeof t.range === "function" : false;
}
function binset(bin3) {
  return [bin3, new Set(bin3)];
}
function bincumset([bin3], j, bins) {
  return [
    bin3,
    {
      get size() {
        for (let k = 0; k <= j; ++k) {
          if (bins[k][1].size) {
            return 1;
          }
        }
        return 0;
      },
      has(i) {
        for (let k = 0; k <= j; ++k) {
          if (bins[k][1].has(i)) {
            return true;
          }
        }
        return false;
      }
    }
  ];
}
function binfilter([{ x0: x05, x1: x12 }, set3]) {
  return [x05, x12, set3.size ? (I) => I.filter(set3.has, set3) : binempty];
}
function binempty() {
  return new Uint32Array(0);
}

// node_modules/@observablehq/plot/dist/transforms/identity.js
function maybeIdentityX(options = {}) {
  const { x: x2, x1: x12, x2: x22 } = options;
  return x12 === void 0 && x22 === void 0 && x2 === void 0 ? { ...options, x: identity3 } : options;
}
function maybeIdentityY(options = {}) {
  const { y: y2, y1: y12, y2: y22 } = options;
  return y12 === void 0 && y22 === void 0 && y2 === void 0 ? { ...options, y: identity3 } : options;
}

// node_modules/@observablehq/plot/dist/transforms/stack.js
function stackX(stack2 = {}, options = {}) {
  if (arguments.length === 1)
    [stack2, options] = mergeOptions2(stack2);
  const { y1: y12, y: y2 = y12, x: x2, ...rest } = options;
  const [transform2, Y3, x12, x22] = stackAlias(y2, x2, "x", stack2, rest);
  return { ...transform2, y1: y12, y: Y3, x1: x12, x2: x22, x: mid(x12, x22) };
}
function stackX1(stack2 = {}, options = {}) {
  if (arguments.length === 1)
    [stack2, options] = mergeOptions2(stack2);
  const { y1: y12, y: y2 = y12, x: x2 } = options;
  const [transform2, Y3, X3] = stackAlias(y2, x2, "x", stack2, options);
  return { ...transform2, y1: y12, y: Y3, x: X3 };
}
function stackX2(stack2 = {}, options = {}) {
  if (arguments.length === 1)
    [stack2, options] = mergeOptions2(stack2);
  const { y1: y12, y: y2 = y12, x: x2 } = options;
  const [transform2, Y3, , X3] = stackAlias(y2, x2, "x", stack2, options);
  return { ...transform2, y1: y12, y: Y3, x: X3 };
}
function stackY(stack2 = {}, options = {}) {
  if (arguments.length === 1)
    [stack2, options] = mergeOptions2(stack2);
  const { x1: x12, x: x2 = x12, y: y2, ...rest } = options;
  const [transform2, X3, y12, y22] = stackAlias(x2, y2, "y", stack2, rest);
  return { ...transform2, x1: x12, x: X3, y1: y12, y2: y22, y: mid(y12, y22) };
}
function stackY1(stack2 = {}, options = {}) {
  if (arguments.length === 1)
    [stack2, options] = mergeOptions2(stack2);
  const { x1: x12, x: x2 = x12, y: y2 } = options;
  const [transform2, X3, Y3] = stackAlias(x2, y2, "y", stack2, options);
  return { ...transform2, x1: x12, x: X3, y: Y3 };
}
function stackY2(stack2 = {}, options = {}) {
  if (arguments.length === 1)
    [stack2, options] = mergeOptions2(stack2);
  const { x1: x12, x: x2 = x12, y: y2 } = options;
  const [transform2, X3, , Y3] = stackAlias(x2, y2, "y", stack2, options);
  return { ...transform2, x1: x12, x: X3, y: Y3 };
}
function maybeStackX({ x: x2, x1: x12, x2: x22, ...options } = {}) {
  if (x12 === void 0 && x22 === void 0)
    return stackX({ x: x2, ...options });
  [x12, x22] = maybeZero(x2, x12, x22);
  return { ...options, x1: x12, x2: x22 };
}
function maybeStackY({ y: y2, y1: y12, y2: y22, ...options } = {}) {
  if (y12 === void 0 && y22 === void 0)
    return stackY({ y: y2, ...options });
  [y12, y22] = maybeZero(y2, y12, y22);
  return { ...options, y1: y12, y2: y22 };
}
function mergeOptions2(options) {
  const { offset: offset2, order: order2, reverse: reverse3, ...rest } = options;
  return [{ offset: offset2, order: order2, reverse: reverse3 }, rest];
}
function stack(x2, y2 = one, ky, { offset: offset2, order: order2, reverse: reverse3 }, options) {
  const z = maybeZ(options);
  const [X3, setX] = maybeColumn(x2);
  const [Y12, setY1] = column(y2);
  const [Y22, setY2] = column(y2);
  offset2 = maybeOffset(offset2);
  order2 = maybeOrder(order2, offset2, ky);
  return [
    basic(options, (data, facets) => {
      const X4 = x2 == null ? void 0 : setX(valueof(data, x2));
      const Y3 = valueof(data, y2, Float64Array);
      const Z = valueof(data, z);
      const O = order2 && order2(data, X4, Y3, Z);
      const n = data.length;
      const Y13 = setY1(new Float64Array(n));
      const Y23 = setY2(new Float64Array(n));
      const facetstacks = [];
      for (const facet of facets) {
        const stacks = X4 ? Array.from(group(facet, (i) => X4[i]).values()) : [facet];
        if (O)
          applyOrder(stacks, O);
        for (const stack2 of stacks) {
          let yn = 0, yp = 0;
          if (reverse3)
            stack2.reverse();
          for (const i of stack2) {
            const y3 = Y3[i];
            if (y3 < 0)
              yn = Y23[i] = (Y13[i] = yn) + y3;
            else if (y3 > 0)
              yp = Y23[i] = (Y13[i] = yp) + y3;
            else
              Y23[i] = Y13[i] = yp;
          }
        }
        facetstacks.push(stacks);
      }
      if (offset2)
        offset2(facetstacks, Y13, Y23, Z);
      return { data, facets };
    }),
    X3,
    Y12,
    Y22
  ];
}
var stackAlias = stack;
function maybeOffset(offset2) {
  if (offset2 == null)
    return;
  if (typeof offset2 === "function")
    return offset2;
  switch (`${offset2}`.toLowerCase()) {
    case "expand":
    case "normalize":
      return offsetExpand;
    case "center":
    case "silhouette":
      return offsetCenter;
    case "wiggle":
      return offsetWiggle;
  }
  throw new Error(`unknown offset: ${offset2}`);
}
function extent2(stack2, Y22) {
  let min3 = 0, max4 = 0;
  for (const i of stack2) {
    const y2 = Y22[i];
    if (y2 < min3)
      min3 = y2;
    if (y2 > max4)
      max4 = y2;
  }
  return [min3, max4];
}
function offsetExpand(facetstacks, Y12, Y22) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn, yp] = extent2(stack2, Y22);
      for (const i of stack2) {
        const m = 1 / (yp - yn || 1);
        Y12[i] = m * (Y12[i] - yn);
        Y22[i] = m * (Y22[i] - yn);
      }
    }
  }
}
function offsetCenter(facetstacks, Y12, Y22) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn, yp] = extent2(stack2, Y22);
      for (const i of stack2) {
        const m = (yp + yn) / 2;
        Y12[i] -= m;
        Y22[i] -= m;
      }
    }
    offsetZero(stacks, Y12, Y22);
  }
  offsetCenterFacets(facetstacks, Y12, Y22);
}
function offsetWiggle(facetstacks, Y12, Y22, Z) {
  for (const stacks of facetstacks) {
    const prev = new InternMap();
    let y2 = 0;
    for (const stack2 of stacks) {
      let j = -1;
      const Fi = stack2.map((i) => Math.abs(Y22[i] - Y12[i]));
      const Df = stack2.map((i) => {
        j = Z ? Z[i] : ++j;
        const value = Y22[i] - Y12[i];
        const diff = prev.has(j) ? value - prev.get(j) : 0;
        prev.set(j, value);
        return diff;
      });
      const Cf1 = [0, ...cumsum(Df)];
      for (const i of stack2) {
        Y12[i] += y2;
        Y22[i] += y2;
      }
      const s1 = sum(Fi);
      if (s1)
        y2 -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;
    }
    offsetZero(stacks, Y12, Y22);
  }
  offsetCenterFacets(facetstacks, Y12, Y22);
}
function offsetZero(stacks, Y12, Y22) {
  const m = min(stacks, (stack2) => min(stack2, (i) => Y12[i]));
  for (const stack2 of stacks) {
    for (const i of stack2) {
      Y12[i] -= m;
      Y22[i] -= m;
    }
  }
}
function offsetCenterFacets(facetstacks, Y12, Y22) {
  const n = facetstacks.length;
  if (n === 1)
    return;
  const facets = facetstacks.map((stacks) => stacks.flat());
  const m = facets.map((I) => (min(I, (i) => Y12[i]) + max(I, (i) => Y22[i])) / 2);
  const m0 = min(m);
  for (let j = 0; j < n; j++) {
    const p = m0 - m[j];
    for (const i of facets[j]) {
      Y12[i] += p;
      Y22[i] += p;
    }
  }
}
function maybeOrder(order2, offset2, ky) {
  if (order2 === void 0 && offset2 === offsetWiggle)
    return orderInsideOut;
  if (order2 == null)
    return;
  if (typeof order2 === "string") {
    switch (order2.toLowerCase()) {
      case "value":
      case ky:
        return orderY;
      case "z":
        return orderZ;
      case "sum":
        return orderSum;
      case "appearance":
        return orderAppearance;
      case "inside-out":
        return orderInsideOut;
    }
    return orderFunction(field(order2));
  }
  if (typeof order2 === "function")
    return orderFunction(order2);
  if (Array.isArray(order2))
    return orderGiven(order2);
  throw new Error(`invalid order: ${order2}`);
}
function orderY(data, X3, Y3) {
  return Y3;
}
function orderZ(order2, X3, Y3, Z) {
  return Z;
}
function orderSum(data, X3, Y3, Z) {
  return orderZDomain(Z, groupSort(range2(data), (I) => sum(I, (i) => Y3[i]), (i) => Z[i]));
}
function orderAppearance(data, X3, Y3, Z) {
  return orderZDomain(Z, groupSort(range2(data), (I) => X3[greatest(I, (i) => Y3[i])], (i) => Z[i]));
}
function orderInsideOut(data, X3, Y3, Z) {
  const I = range2(data);
  const K = groupSort(I, (I2) => X3[greatest(I2, (i) => Y3[i])], (i) => Z[i]);
  const sums = rollup(I, (I2) => sum(I2, (i) => Y3[i]), (i) => Z[i]);
  const Kp = [], Kn = [];
  let s = 0;
  for (const k of K) {
    if (s < 0) {
      s += sums.get(k);
      Kp.push(k);
    } else {
      s -= sums.get(k);
      Kn.push(k);
    }
  }
  return orderZDomain(Z, Kn.reverse().concat(Kp));
}
function orderFunction(f) {
  return (data) => valueof(data, f);
}
function orderGiven(domain) {
  return (data, X3, Y3, Z) => orderZDomain(Z, domain);
}
function orderZDomain(Z, domain) {
  domain = new InternMap(domain.map((d, i) => [d, i]));
  return Z.map((z) => domain.get(z));
}
function applyOrder(stacks, O) {
  for (const stack2 of stacks) {
    stack2.sort((i, j) => ascendingDefined(O[i], O[j]));
  }
}

// node_modules/@observablehq/plot/dist/marks/area.js
var defaults = {
  ariaLabel: "area",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Area = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, y1: y12, x2, y2, z, curve, tension } = options;
    super(data, {
      x1: { value: x12, scale: "x" },
      y1: { value: y12, scale: "y" },
      x2: { value: x2, scale: "x", optional: true },
      y2: { value: y2, scale: "y", optional: true },
      z: { value: maybeZ(options), optional: true }
    }, options, defaults);
    this.z = z;
    this.curve = Curve(curve, tension);
  }
  filter(index) {
    return index;
  }
  render(index, scales, channels, dimensions, context) {
    const { x1: X12, y1: Y12, x2: X22 = X12, y2: Y22 = Y12 } = channels;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales, 0, 0).call((g) => g.selectAll().data(groupIndex(index, [X12, Y12, X22, Y22], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr("d", area_default().curve(this.curve).defined((i) => i >= 0).x0((i) => X12[i]).y0((i) => Y12[i]).x1((i) => X22[i]).y1((i) => Y22[i]))).node();
  }
};
function area(data, options) {
  if (options === void 0)
    return areaY(data, { x: first, y: second });
  return new Area(data, options);
}
function areaX(data, options) {
  const { y: y2 = indexOf, ...rest } = maybeDenseIntervalY(options);
  return new Area(data, maybeStackX(maybeIdentityX({ ...rest, y1: y2, y2: void 0 })));
}
function areaY(data, options) {
  const { x: x2 = indexOf, ...rest } = maybeDenseIntervalX(options);
  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x2, x2: void 0 })));
}

// node_modules/@observablehq/plot/dist/marks/marker.js
function markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {
  mark.markerStart = maybeMarker(markerStart);
  mark.markerMid = maybeMarker(markerMid);
  mark.markerEnd = maybeMarker(markerEnd);
}
function maybeMarker(marker) {
  if (marker == null || marker === false)
    return null;
  if (marker === true)
    return markerCircleFill;
  if (typeof marker === "function")
    return marker;
  switch (`${marker}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return markerArrow;
    case "dot":
      return markerDot;
    case "circle":
    case "circle-fill":
      return markerCircleFill;
    case "circle-stroke":
      return markerCircleStroke;
  }
  throw new Error(`invalid marker: ${marker}`);
}
function markerArrow(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", "auto").attr("fill", "none").attr("stroke", color3).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function markerDot(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
}
function markerCircleFill(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "white").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerCircleStroke(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "white").attr("stroke", color3).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
var nextMarkerId = 0;
function applyMarkers(path, mark, { stroke: S } = {}) {
  return applyMarkersColor(path, mark, S && ((i) => S[i]));
}
function applyGroupedMarkers(path, mark, { stroke: S } = {}) {
  return applyMarkersColor(path, mark, S && (([i]) => S[i]));
}
function applyMarkersColor(path, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke) {
  const iriByMarkerColor = /* @__PURE__ */ new Map();
  function applyMarker(marker) {
    return function(i) {
      const color3 = strokeof(i);
      let iriByColor = iriByMarkerColor.get(marker);
      if (!iriByColor)
        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
      let iri = iriByColor.get(color3);
      if (!iri) {
        const context = { document: this.ownerDocument };
        const node = this.parentNode.insertBefore(marker(color3, context), this);
        const id2 = `plot-marker-${++nextMarkerId}`;
        node.setAttribute("id", id2);
        iriByColor.set(color3, iri = `url(#${id2})`);
      }
      return iri;
    };
  }
  if (markerStart)
    path.attr("marker-start", applyMarker(markerStart));
  if (markerMid)
    path.attr("marker-mid", applyMarker(markerMid));
  if (markerEnd)
    path.attr("marker-end", applyMarker(markerEnd));
}

// node_modules/@observablehq/plot/dist/marks/link.js
var defaults2 = {
  ariaLabel: "link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var Link = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, y1: y12, x2, y2, curve, tension } = options;
    super(data, {
      x1: { value: x12, scale: "x" },
      y1: { value: y12, scale: "y" },
      x2: { value: x2, scale: "x", optional: true },
      y2: { value: y2, scale: "y", optional: true }
    }, options, defaults2);
    this.curve = Curve(curve, tension);
    markers(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { x1: X12, y1: Y12, x2: X22 = X12, y2: Y22 = Y12 } = channels;
    const { curve } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => {
      const p = path_default();
      const c3 = curve(p);
      c3.lineStart();
      c3.point(X12[i], Y12[i]);
      c3.point(X22[i], Y22[i]);
      c3.lineEnd();
      return p;
    }).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels)).node();
  }
};
function link2(data, options = {}) {
  let { x: x2, x1: x12, x2: x22, y: y2, y1: y12, y2: y22, ...remainingOptions } = options;
  [x12, x22] = maybeSameValue(x2, x12, x22);
  [y12, y22] = maybeSameValue(y2, y12, y22);
  return new Link(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });
}
function maybeSameValue(x2, x12, x22) {
  if (x2 === void 0) {
    if (x12 === void 0) {
      if (x22 !== void 0)
        return [x22];
    } else {
      if (x22 === void 0)
        return [x12];
    }
  } else if (x12 === void 0) {
    return x22 === void 0 ? [x2] : [x2, x22];
  } else if (x22 === void 0) {
    return [x2, x12];
  }
  return [x12, x22];
}

// node_modules/@observablehq/plot/dist/marks/arrow.js
var defaults3 = {
  ariaLabel: "arrow",
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeMiterlimit: 1,
  strokeWidth: 1.5
};
var Arrow = class extends Mark {
  constructor(data, options = {}) {
    const {
      x1: x12,
      y1: y12,
      x2,
      y2,
      bend = 0,
      headAngle = 60,
      headLength = 8,
      inset = 0,
      insetStart = inset,
      insetEnd = inset
    } = options;
    super(data, {
      x1: { value: x12, scale: "x" },
      y1: { value: y12, scale: "y" },
      x2: { value: x2, scale: "x", optional: true },
      y2: { value: y2, scale: "y", optional: true }
    }, options, defaults3);
    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));
    this.headAngle = +headAngle;
    this.headLength = +headLength;
    this.insetStart = +insetStart;
    this.insetEnd = +insetEnd;
  }
  render(index, scales, channels, dimensions, context) {
    const { x1: X12, y1: Y12, x2: X22 = X12, y2: Y22 = Y12, SW } = channels;
    const { strokeWidth, bend, headAngle, headLength, insetStart, insetEnd } = this;
    const sw = SW ? (i) => SW[i] : constant(strokeWidth === void 0 ? 1 : strokeWidth);
    const bendAngle = bend * radians2;
    const wingAngle = headAngle * radians2 / 2;
    const wingScale = headLength / 1.5;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => {
      let x12 = X12[i], y12 = Y12[i], x2 = X22[i], y2 = Y22[i];
      const lineLength = Math.hypot(x2 - x12, y2 - y12);
      if (lineLength <= insetStart + insetEnd)
        return null;
      let lineAngle = Math.atan2(y2 - y12, x2 - x12);
      const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);
      const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;
      if (insetStart || insetEnd) {
        if (r < 1e5) {
          const sign2 = Math.sign(bendAngle);
          const [cx, cy] = pointPointCenter([x12, y12], [x2, y2], r, sign2);
          if (insetStart) {
            [x12, y12] = circleCircleIntersect([cx, cy, r], [x12, y12, insetStart], -sign2 * Math.sign(insetStart));
          }
          if (insetEnd) {
            const [x5, y5] = circleCircleIntersect([cx, cy, r], [x2, y2, insetEnd], sign2 * Math.sign(insetEnd));
            lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y2 - cy, x2 - cx);
            x2 = x5, y2 = y5;
          }
        } else {
          const dx = x2 - x12, dy = y2 - y12, d = Math.hypot(dx, dy);
          if (insetStart)
            x12 += dx / d * insetStart, y12 += dy / d * insetStart;
          if (insetEnd)
            x2 -= dx / d * insetEnd, y2 -= dy / d * insetEnd;
        }
      }
      const endAngle = lineAngle + bendAngle;
      const leftAngle = endAngle + wingAngle;
      const rightAngle = endAngle - wingAngle;
      const x3 = x2 - headLength2 * Math.cos(leftAngle);
      const y3 = y2 - headLength2 * Math.sin(leftAngle);
      const x4 = x2 - headLength2 * Math.cos(rightAngle);
      const y4 = y2 - headLength2 * Math.sin(rightAngle);
      return `M${x12},${y12}${r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`}${x2},${y2}M${x3},${y3}L${x2},${y2}L${x4},${y4}`;
    }).call(applyChannelStyles, this, channels)).node();
  }
};
function pointPointCenter([ax, ay], [bx, by], r, sign2) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const k = sign2 * Math.sqrt(r * r - d * d / 4) / d;
  return [(ax + bx) / 2 - dy * k, (ay + by) / 2 + dx * k];
}
function circleCircleIntersect([ax, ay, ar], [bx, by, br], sign2) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const x2 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);
  const y2 = sign2 * Math.sqrt(ar * ar - x2 * x2);
  return [ax + (dx * x2 + dy * y2) / d, ay + (dy * x2 - dx * y2) / d];
}
function arrow(data, options = {}) {
  let { x: x2, x1: x12, x2: x22, y: y2, y1: y12, y2: y22, ...remainingOptions } = options;
  [x12, x22] = maybeSameValue(x2, x12, x22);
  [y12, y22] = maybeSameValue(y2, y12, y22);
  return new Arrow(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });
}

// node_modules/@observablehq/plot/dist/marks/bar.js
var AbstractBar = class extends Mark {
  constructor(data, channels, options = {}, defaults18) {
    super(data, channels, options, defaults18);
    const { inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;
    this.insetTop = number3(insetTop);
    this.insetRight = number3(insetRight);
    this.insetBottom = number3(insetBottom);
    this.insetLeft = number3(insetLeft);
    this.rx = impliedString(rx, "auto");
    this.ry = impliedString(ry, "auto");
  }
  render(index, scales, channels, dimensions, context) {
    const { rx, ry } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(this._transform, this, scales).call((g) => g.selectAll().data(index).enter().append("rect").call(applyDirectStyles, this).attr("x", this._x(scales, channels, dimensions)).attr("width", this._width(scales, channels, dimensions)).attr("y", this._y(scales, channels, dimensions)).attr("height", this._height(scales, channels, dimensions)).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)).node();
  }
  _x(scales, { x: X3 }, { marginLeft }) {
    const { insetLeft } = this;
    return X3 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;
  }
  _y(scales, { y: Y3 }, { marginTop }) {
    const { insetTop } = this;
    return Y3 ? (i) => Y3[i] + insetTop : marginTop + insetTop;
  }
  _width({ x: x2 }, { x: X3 }, { marginRight, marginLeft, width }) {
    const { insetLeft, insetRight } = this;
    const bandwidth = X3 && x2 ? x2.bandwidth() : width - marginRight - marginLeft;
    return Math.max(0, bandwidth - insetLeft - insetRight);
  }
  _height({ y: y2 }, { y: Y3 }, { marginTop, marginBottom, height }) {
    const { insetTop, insetBottom } = this;
    const bandwidth = Y3 && y2 ? y2.bandwidth() : height - marginTop - marginBottom;
    return Math.max(0, bandwidth - insetTop - insetBottom);
  }
};
var defaults4 = {
  ariaLabel: "bar"
};
var BarX = class extends AbstractBar {
  constructor(data, options = {}) {
    const { x1: x12, x2, y: y2 } = options;
    super(data, {
      x1: { value: x12, scale: "x" },
      x2: { value: x2, scale: "x" },
      y: { value: y2, scale: "y", type: "band", optional: true }
    }, options, defaults4);
  }
  _transform(selection2, mark, { x: x2 }) {
    selection2.call(applyTransform, mark, { x: x2 }, 0, 0);
  }
  _x({ x: x2 }, { x1: X12, x2: X22 }, { marginLeft }) {
    const { insetLeft } = this;
    return isCollapsed(x2) ? marginLeft + insetLeft : (i) => Math.min(X12[i], X22[i]) + insetLeft;
  }
  _width({ x: x2 }, { x1: X12, x2: X22 }, { marginRight, marginLeft, width }) {
    const { insetLeft, insetRight } = this;
    return isCollapsed(x2) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X22[i] - X12[i]) - insetLeft - insetRight);
  }
};
var BarY = class extends AbstractBar {
  constructor(data, options = {}) {
    const { x: x2, y1: y12, y2 } = options;
    super(data, {
      y1: { value: y12, scale: "y" },
      y2: { value: y2, scale: "y" },
      x: { value: x2, scale: "x", type: "band", optional: true }
    }, options, defaults4);
  }
  _transform(selection2, mark, { y: y2 }) {
    selection2.call(applyTransform, mark, { y: y2 }, 0, 0);
  }
  _y({ y: y2 }, { y1: Y12, y2: Y22 }, { marginTop }) {
    const { insetTop } = this;
    return isCollapsed(y2) ? marginTop + insetTop : (i) => Math.min(Y12[i], Y22[i]) + insetTop;
  }
  _height({ y: y2 }, { y1: Y12, y2: Y22 }, { marginTop, marginBottom, height }) {
    const { insetTop, insetBottom } = this;
    return isCollapsed(y2) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y22[i] - Y12[i]) - insetTop - insetBottom);
  }
};
function barX(data, options = { y: indexOf, x2: identity3 }) {
  return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));
}
function barY(data, options = { x: indexOf, y2: identity3 }) {
  return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));
}

// node_modules/@observablehq/plot/dist/transforms/map.js
function mapX(map3, options = {}) {
  return mapAlias(Object.fromEntries(["x", "x1", "x2"].filter((key) => options[key] != null).map((key) => [key, map3])), options);
}
function mapY(map3, options = {}) {
  return mapAlias(Object.fromEntries(["y", "y1", "y2"].filter((key) => options[key] != null).map((key) => [key, map3])), options);
}
function map2(outputs = {}, options = {}) {
  const z = maybeZ(options);
  const channels = Object.entries(outputs).map(([key, map3]) => {
    const input = maybeInput(key, options);
    if (input == null)
      throw new Error(`missing channel: ${key}`);
    const [output, setOutput] = column(input);
    return { key, input, output, setOutput, map: maybeMap(map3) };
  });
  return {
    ...basic(options, (data, facets) => {
      const Z = valueof(data, z);
      const X3 = channels.map(({ input }) => valueof(data, input));
      const MX = channels.map(({ setOutput }) => setOutput(new Array(data.length)));
      for (const facet of facets) {
        for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
          channels.forEach(({ map: map3 }, i) => map3.map(I, X3[i], MX[i]));
        }
      }
      return { data, facets };
    }),
    ...Object.fromEntries(channels.map(({ key, output }) => [key, output]))
  };
}
var mapAlias = map2;
function maybeMap(map3) {
  if (map3 && typeof map3.map === "function")
    return map3;
  if (typeof map3 === "function")
    return mapFunction(map3);
  switch (`${map3}`.toLowerCase()) {
    case "cumsum":
      return mapCumsum;
    case "rank":
      return mapFunction(rank);
    case "quantile":
      return mapFunction(rankQuantile);
  }
  throw new Error(`invalid map: ${map3}`);
}
function rankQuantile(V) {
  const n = count(V) - 1;
  return rank(V).map((r) => r / n);
}
function mapFunction(f) {
  return {
    map(I, S, T) {
      const M2 = f(take(S, I));
      if (M2.length !== I.length)
        throw new Error("map function returned a mismatched length");
      for (let i = 0, n = I.length; i < n; ++i)
        T[I[i]] = M2[i];
    }
  };
}
var mapCumsum = {
  map(I, S, T) {
    let sum2 = 0;
    for (const i of I)
      T[i] = sum2 += S[i];
  }
};

// node_modules/@observablehq/plot/dist/marks/dot.js
var defaults5 = {
  ariaLabel: "dot",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5
};
var Dot = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y: y2, r, rotate, symbol: symbol2 = circle_default, frameAnchor } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);
    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      r: { value: vr, scale: "r", filter: positive, optional: true },
      rotate: { value: vrotate, optional: true },
      symbol: { value: vsymbol, scale: "symbol", optional: true }
    }, options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: "r", order: "descending" }, options) : options, defaults5);
    this.r = cr;
    this.rotate = crotate;
    this.symbol = csymbol;
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    const { channels } = this;
    const { symbol: symbolChannel } = channels;
    if (symbolChannel) {
      const { fill: fillChannel, stroke: strokeChannel } = channels;
      symbolChannel.hint = {
        fill: fillChannel ? fillChannel.value === symbolChannel.value ? "color" : "currentColor" : this.fill,
        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? "color" : "currentColor" : this.stroke
      };
    }
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, r: R, rotate: A, symbol: S } = channels;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const circle3 = this.symbol === circle_default;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(index).enter().append(circle3 ? "circle" : "path").call(applyDirectStyles, this).call(circle3 ? (selection2) => {
      selection2.attr("cx", X3 ? (i) => X3[i] : cx).attr("cy", Y3 ? (i) => Y3[i] : cy).attr("r", R ? (i) => R[i] : this.r);
    } : (selection2) => {
      const translate = X3 && Y3 ? (i) => `translate(${X3[i]},${Y3[i]})` : X3 ? (i) => `translate(${X3[i]},${cy})` : Y3 ? (i) => `translate(${cx},${Y3[i]})` : () => `translate(${cx},${cy})`;
      selection2.attr("transform", A ? (i) => `${translate(i)} rotate(${A[i]})` : this.rotate ? (i) => `${translate(i)} rotate(${this.rotate})` : translate).attr("d", (i) => {
        const p = path_default(), r = R ? R[i] : this.r;
        (S ? S[i] : this.symbol).draw(p, r * r * Math.PI);
        return p;
      });
    }).call(applyChannelStyles, this, channels)).node();
  }
};
function dot(data, options = {}) {
  let { x: x2, y: y2, ...remainingOptions } = options;
  if (options.frameAnchor === void 0)
    [x2, y2] = maybeTuple(x2, y2);
  return new Dot(data, { ...remainingOptions, x: x2, y: y2 });
}
function dotX(data, options = {}) {
  const { x: x2 = identity3, ...remainingOptions } = options;
  return new Dot(data, maybeIntervalMidY({ ...remainingOptions, x: x2 }));
}
function dotY(data, options = {}) {
  const { y: y2 = identity3, ...remainingOptions } = options;
  return new Dot(data, maybeIntervalMidX({ ...remainingOptions, y: y2 }));
}
function circle2(data, options) {
  return dot(data, { ...options, symbol: "circle" });
}
function hexagon(data, options) {
  return dot(data, { ...options, symbol: "hexagon" });
}

// node_modules/@observablehq/plot/dist/marks/rule.js
var defaults6 = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
var RuleX = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y1: y12, y2, inset = 0, insetTop = inset, insetBottom = inset } = options;
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y1: { value: y12, scale: "y", optional: true },
      y2: { value: y2, scale: "y", optional: true }
    }, options, defaults6);
    this.insetTop = number3(insetTop);
    this.insetBottom = number3(insetBottom);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: x2, y: y2 } = scales;
    const { x: X3, y1: Y12, y2: Y22 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetTop, insetBottom } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, { x: X3 && x2 }, offset, 0).call((g) => g.selectAll().data(index).enter().append("line").call(applyDirectStyles, this).attr("x1", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr("x2", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr("y1", Y12 && !isCollapsed(y2) ? (i) => Y12[i] + insetTop : marginTop + insetTop).attr("y2", Y22 && !isCollapsed(y2) ? y2.bandwidth ? (i) => Y22[i] + y2.bandwidth() - insetBottom : (i) => Y22[i] - insetBottom : height - marginBottom - insetBottom).call(applyChannelStyles, this, channels)).node();
  }
};
var RuleY = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, x2, y: y2, inset = 0, insetRight = inset, insetLeft = inset } = options;
    super(data, {
      y: { value: y2, scale: "y", optional: true },
      x1: { value: x12, scale: "x", optional: true },
      x2: { value: x2, scale: "x", optional: true }
    }, options, defaults6);
    this.insetRight = number3(insetRight);
    this.insetLeft = number3(insetLeft);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: x2, y: y2 } = scales;
    const { y: Y3, x1: X12, x2: X22 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetLeft, insetRight } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, { y: Y3 && y2 }, 0, offset).call((g) => g.selectAll().data(index).enter().append("line").call(applyDirectStyles, this).attr("x1", X12 && !isCollapsed(x2) ? (i) => X12[i] + insetLeft : marginLeft + insetLeft).attr("x2", X22 && !isCollapsed(x2) ? x2.bandwidth ? (i) => X22[i] + x2.bandwidth() - insetRight : (i) => X22[i] - insetRight : width - marginRight - insetRight).attr("y1", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).attr("y2", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels)).node();
  }
};
function ruleX(data, options) {
  let { x: x2 = identity3, y: y2, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);
  [y12, y22] = maybeOptionalZero(y2, y12, y22);
  return new RuleX(data, { ...rest, x: x2, y1: y12, y2: y22 });
}
function ruleY(data, options) {
  let { y: y2 = identity3, x: x2, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);
  [x12, x22] = maybeOptionalZero(x2, x12, x22);
  return new RuleY(data, { ...rest, y: y2, x1: x12, x2: x22 });
}
function maybeOptionalZero(x2, x12, x22) {
  if (x2 === void 0) {
    if (x12 === void 0) {
      if (x22 !== void 0)
        return [0, x22];
    } else {
      if (x22 === void 0)
        return [0, x12];
    }
  } else if (x12 === void 0) {
    return x22 === void 0 ? [0, x2] : [x2, x22];
  } else if (x22 === void 0) {
    return [x2, x12];
  }
  return [x12, x22];
}

// node_modules/@observablehq/plot/dist/marks/tick.js
var defaults7 = {
  ariaLabel: "tick",
  fill: null,
  stroke: "currentColor"
};
var AbstractTick = class extends Mark {
  constructor(data, channels, options) {
    super(data, channels, options, defaults7);
  }
  render(index, scales, channels, dimensions, context) {
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(this._transform, this, scales).call((g) => g.selectAll().data(index).enter().append("line").call(applyDirectStyles, this).attr("x1", this._x1(scales, channels, dimensions)).attr("x2", this._x2(scales, channels, dimensions)).attr("y1", this._y1(scales, channels, dimensions)).attr("y2", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels)).node();
  }
};
var TickX = class extends AbstractTick {
  constructor(data, options = {}) {
    const { x: x2, y: y2, inset = 0, insetTop = inset, insetBottom = inset } = options;
    super(data, {
      x: { value: x2, scale: "x" },
      y: { value: y2, scale: "y", type: "band", optional: true }
    }, options);
    this.insetTop = number3(insetTop);
    this.insetBottom = number3(insetBottom);
  }
  _transform(selection2, mark, { x: x2 }) {
    selection2.call(applyTransform, mark, { x: x2 }, offset, 0);
  }
  _x1(scales, { x: X3 }) {
    return (i) => X3[i];
  }
  _x2(scales, { x: X3 }) {
    return (i) => X3[i];
  }
  _y1({ y: y2 }, { y: Y3 }, { marginTop }) {
    const { insetTop } = this;
    return Y3 && y2 ? (i) => Y3[i] + insetTop : marginTop + insetTop;
  }
  _y2({ y: y2 }, { y: Y3 }, { height, marginBottom }) {
    const { insetBottom } = this;
    return Y3 && y2 ? (i) => Y3[i] + y2.bandwidth() - insetBottom : height - marginBottom - insetBottom;
  }
};
var TickY = class extends AbstractTick {
  constructor(data, options = {}) {
    const { x: x2, y: y2, inset = 0, insetRight = inset, insetLeft = inset } = options;
    super(data, {
      y: { value: y2, scale: "y" },
      x: { value: x2, scale: "x", type: "band", optional: true }
    }, options);
    this.insetRight = number3(insetRight);
    this.insetLeft = number3(insetLeft);
  }
  _transform(selection2, mark, { y: y2 }) {
    selection2.call(applyTransform, mark, { y: y2 }, 0, offset);
  }
  _x1({ x: x2 }, { x: X3 }, { marginLeft }) {
    const { insetLeft } = this;
    return X3 && x2 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;
  }
  _x2({ x: x2 }, { x: X3 }, { width, marginRight }) {
    const { insetRight } = this;
    return X3 && x2 ? (i) => X3[i] + x2.bandwidth() - insetRight : width - marginRight - insetRight;
  }
  _y1(scales, { y: Y3 }) {
    return (i) => Y3[i];
  }
  _y2(scales, { y: Y3 }) {
    return (i) => Y3[i];
  }
};
function tickX(data, options = {}) {
  const { x: x2 = identity3, ...remainingOptions } = options;
  return new TickX(data, { ...remainingOptions, x: x2 });
}
function tickY(data, options = {}) {
  const { y: y2 = identity3, ...remainingOptions } = options;
  return new TickY(data, { ...remainingOptions, y: y2 });
}

// node_modules/@observablehq/plot/dist/marks/box.js
function boxX(data, options = {}) {
  const { x: x2 = { transform: (x3) => x3 }, y: y2 = null, fill = "#ccc", fillOpacity, stroke = "currentColor", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;
  const group3 = y2 != null ? groupY : groupZ2;
  return marks(ruleY(data, group3({ x1: loqr1, x2: hiqr2 }, { x: x2, y: y2, stroke, strokeOpacity, ...remainingOptions })), barX(data, group3({ x1: "p25", x2: "p75" }, { x: x2, y: y2, fill, fillOpacity, ...remainingOptions })), tickX(data, group3({ x: "p50" }, { x: x2, y: y2, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map2({ x: oqr }, { x: x2, y: y2, z: y2, stroke, strokeOpacity, ...remainingOptions })));
}
function boxY(data, options = {}) {
  const { y: y2 = { transform: (y3) => y3 }, x: x2 = null, fill = "#ccc", fillOpacity, stroke = "currentColor", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;
  const group3 = x2 != null ? groupX : groupZ2;
  return marks(ruleX(data, group3({ y1: loqr1, y2: hiqr2 }, { x: x2, y: y2, stroke, strokeOpacity, ...remainingOptions })), barY(data, group3({ y1: "p25", y2: "p75" }, { x: x2, y: y2, fill, fillOpacity, ...remainingOptions })), tickY(data, group3({ y: "p50" }, { x: x2, y: y2, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map2({ y: oqr }, { x: x2, y: y2, z: x2, stroke, strokeOpacity, ...remainingOptions })));
}
function oqr(values2) {
  const r1 = loqr1(values2);
  const r2 = hiqr2(values2);
  return values2.map((v) => v < r1 || v > r2 ? v : NaN);
}
function loqr1(values2, value) {
  const lo = quartile1(values2, value) * 2.5 - quartile3(values2, value) * 1.5;
  return min(values2, (d) => d >= lo ? d : NaN);
}
function hiqr2(values2, value) {
  const hi = quartile3(values2, value) * 2.5 - quartile1(values2, value) * 1.5;
  return max(values2, (d) => d <= hi ? d : NaN);
}
function quartile1(values2, value) {
  return quantile(values2, 0.25, value);
}
function quartile3(values2, value) {
  return quantile(values2, 0.75, value);
}

// node_modules/@observablehq/plot/dist/marks/cell.js
var defaults8 = {
  ariaLabel: "cell"
};
var Cell = class extends AbstractBar {
  constructor(data, { x: x2, y: y2, ...options } = {}) {
    super(data, {
      x: { value: x2, scale: "x", type: "band", optional: true },
      y: { value: y2, scale: "y", type: "band", optional: true }
    }, options, defaults8);
  }
  _transform(selection2, mark) {
    selection2.call(applyTransform, mark, {}, 0, 0);
  }
};
function cell(data, options = {}) {
  let { x: x2, y: y2, ...remainingOptions } = options;
  [x2, y2] = maybeTuple(x2, y2);
  return new Cell(data, { ...remainingOptions, x: x2, y: y2 });
}
function cellX(data, options = {}) {
  let { x: x2 = indexOf, fill, stroke, ...remainingOptions } = options;
  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
    fill = identity3;
  return new Cell(data, { ...remainingOptions, x: x2, fill, stroke });
}
function cellY(data, options = {}) {
  let { y: y2 = indexOf, fill, stroke, ...remainingOptions } = options;
  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
    fill = identity3;
  return new Cell(data, { ...remainingOptions, y: y2, fill, stroke });
}

// node_modules/@observablehq/plot/dist/marks/delaunay.js
var delaunayLinkDefaults = {
  ariaLabel: "delaunay link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var delaunayMeshDefaults = {
  ariaLabel: "delaunay mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
var hullDefaults = {
  ariaLabel: "hull",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeMiterlimit: 1
};
var voronoiDefaults = {
  ariaLabel: "voronoi",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var voronoiMeshDefaults = {
  ariaLabel: "voronoi mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
var DelaunayLink = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y: y2, z, curve, tension } = options;
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      z: { value: z, optional: true }
    }, options, delaunayLinkDefaults);
    this.curve = Curve(curve, tension);
    markers(this, options);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, z: Z } = channels;
    const { curve } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X3 ? (i) => X3[i] : constant(cx);
    const yi = Y3 ? (i) => Y3[i] : constant(cy);
    const mark = this;
    function links(index2) {
      let i = -1;
      const newIndex = [];
      const newChannels = {};
      for (const k in channels)
        newChannels[k] = [];
      const X12 = [];
      const X22 = [];
      const Y12 = [];
      const Y22 = [];
      function link3(ti, tj) {
        ti = index2[ti];
        tj = index2[tj];
        newIndex.push(++i);
        X12[i] = xi(ti);
        Y12[i] = yi(ti);
        X22[i] = xi(tj);
        Y22[i] = yi(tj);
        for (const k in channels)
          newChannels[k].push(channels[k][tj]);
      }
      const { halfedges, hull: hull2, triangles } = Delaunay.from(index2, xi, yi);
      for (let i2 = 0; i2 < halfedges.length; ++i2) {
        const j = halfedges[i2];
        if (j > i2)
          link3(triangles[i2], triangles[j]);
      }
      for (let i2 = 0; i2 < hull2.length; ++i2) {
        link3(hull2[i2], hull2[(i2 + 1) % hull2.length]);
      }
      select_default2(this).selectAll().data(newIndex).join("path").call(applyDirectStyles, mark).attr("d", (i2) => {
        const p = path_default();
        const c3 = curve(p);
        c3.lineStart();
        c3.point(X12[i2], Y12[i2]);
        c3.point(X22[i2], Y22[i2]);
        c3.lineEnd();
        return p;
      }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels);
    }
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call(Z ? (g) => g.selectAll().data(group(index, (i) => Z[i]).values()).enter().append("g").each(links) : (g) => g.datum(index).each(links)).node();
  }
};
var AbstractDelaunayMark = class extends Mark {
  constructor(data, options = {}, defaults18, zof = ({ z }) => z) {
    const { x: x2, y: y2 } = options;
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      z: { value: zof(options), optional: true }
    }, options, defaults18);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, z: Z } = channels;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X3 ? (i) => X3[i] : constant(cx);
    const yi = Y3 ? (i) => Y3[i] : constant(cy);
    const mark = this;
    function mesh(index2) {
      const delaunay = Delaunay.from(index2, xi, yi);
      select_default2(this).append("path").datum(index2[0]).call(applyDirectStyles, mark).attr("d", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);
    }
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call(Z ? (g) => g.selectAll().data(group(index, (i) => Z[i]).values()).enter().append("g").each(mesh) : (g) => g.datum(index).each(mesh)).node();
  }
};
var DelaunayMesh = class extends AbstractDelaunayMark {
  constructor(data, options = {}) {
    super(data, options, delaunayMeshDefaults);
    this.fill = "none";
  }
  _render(delaunay) {
    return delaunay.render();
  }
};
var Hull = class extends AbstractDelaunayMark {
  constructor(data, options = {}) {
    super(data, options, hullDefaults, maybeZ);
  }
  _render(delaunay) {
    return delaunay.renderHull();
  }
};
var Voronoi = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y: y2, z } = options;
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      z: { value: z, optional: true }
    }, options, voronoiDefaults);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, z: Z } = channels;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X3 ? (i) => X3[i] : constant(cx);
    const yi = Y3 ? (i) => Y3[i] : constant(cy);
    function cells(index2) {
      const delaunay = Delaunay.from(index2, xi, yi);
      const voronoi2 = voronoiof(delaunay, dimensions);
      select_default2(this).selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", (_, i) => voronoi2.renderCell(i)).call(applyChannelStyles, this, channels);
    }
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call(Z ? (g) => g.selectAll().data(group(index, (i) => Z[i]).values()).enter().append("g").each(cells) : (g) => g.datum(index).each(cells)).node();
  }
};
var VoronoiMesh = class extends AbstractDelaunayMark {
  constructor(data, options) {
    super(data, options, voronoiMeshDefaults);
    this.fill = "none";
  }
  _render(delaunay, dimensions) {
    return voronoiof(delaunay, dimensions).render();
  }
};
function voronoiof(delaunay, dimensions) {
  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;
  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);
}
function delaunayMark(DelaunayMark, data, { x: x2, y: y2, ...options } = {}) {
  [x2, y2] = maybeTuple(x2, y2);
  return new DelaunayMark(data, { ...options, x: x2, y: y2 });
}
function delaunayLink(data, options) {
  return delaunayMark(DelaunayLink, data, options);
}
function delaunayMesh(data, options) {
  return delaunayMark(DelaunayMesh, data, options);
}
function hull(data, options) {
  return delaunayMark(Hull, data, options);
}
function voronoi(data, options) {
  return delaunayMark(Voronoi, data, options);
}
function voronoiMesh(data, options) {
  return delaunayMark(VoronoiMesh, data, options);
}

// node_modules/@observablehq/plot/dist/marks/density.js
var defaults9 = {
  ariaLabel: "density",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var Density = class extends Mark {
  constructor(data, { x: x2, y: y2, z, weight, fill, stroke, ...options } = {}) {
    const fillDensity = isDensity(fill) && (fill = "currentColor", true);
    const strokeDensity = isDensity(stroke) && (stroke = "currentColor", true);
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      z: { value: maybeZ({ z, fill, stroke }), optional: true },
      weight: { value: weight, optional: true }
    }, densityInitializer({ ...options, fill, stroke }, fillDensity, strokeDensity), defaults9);
    if (fillDensity)
      this.fill = void 0;
    if (strokeDensity)
      this.stroke = void 0;
    this.z = z;
  }
  filter(index) {
    return index;
  }
  render(index, scales, channels, dimensions, context) {
    const { contours } = channels;
    const path = path_default2();
    return create_default("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", (i) => path(contours[i]))).node();
  }
};
function density(data, options = {}) {
  let { x: x2, y: y2, ...remainingOptions } = options;
  [x2, y2] = maybeTuple(x2, y2);
  return new Density(data, { ...remainingOptions, x: x2, y: y2 });
}
var dropChannels = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
function densityInitializer(options, fillDensity, strokeDensity) {
  const k = 100;
  let { bandwidth, thresholds } = options;
  bandwidth = bandwidth === void 0 ? 20 : +bandwidth;
  thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === "function" ? coerceNumbers(thresholds) : +thresholds;
  return initializer(options, function(data, facets, channels, scales, dimensions) {
    const X3 = channels.x ? coerceNumbers(valueof(channels.x.value, scales[channels.x.scale] || identity3)) : null;
    const Y3 = channels.y ? coerceNumbers(valueof(channels.y.value, scales[channels.y.scale] || identity3)) : null;
    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;
    const Z = channels.z?.value;
    const { z } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const { width, height } = dimensions;
    const newChannels = Object.fromEntries(Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, { ...channel, value: [] }]));
    const FD = fillDensity && [];
    const SD = strokeDensity && [];
    const density2 = density_default().x(X3 ? (i) => X3[i] : cx).y(Y3 ? (i) => Y3[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);
    const facetsContours = [];
    for (const facet of facets) {
      const facetContours = [];
      facetsContours.push(facetContours);
      for (const index of Z ? groupZ(facet, Z, z) : [facet]) {
        const contour = density2.contours(index);
        facetContours.push([index, contour]);
      }
    }
    let T = thresholds;
    if (!isTypedArray(T)) {
      let maxValue = 0;
      for (const facetContours of facetsContours) {
        for (const [, contour] of facetContours) {
          const max4 = contour.max;
          if (max4 > maxValue)
            maxValue = max4;
        }
      }
      T = Float64Array.from({ length: thresholds - 1 }, (_, i) => maxValue * k * (i + 1) / thresholds);
    }
    const newFacets = [];
    const contours = [];
    for (const facetContours of facetsContours) {
      const newFacet = [];
      newFacets.push(newFacet);
      for (const [index, contour] of facetContours) {
        for (const t of T) {
          newFacet.push(contours.length);
          contours.push(contour(t / k));
          if (FD)
            FD.push(t);
          if (SD)
            SD.push(t);
          for (const key in newChannels) {
            newChannels[key].value.push(channels[key].value[index[0]]);
          }
        }
      }
    }
    if (FD)
      FD.push(0);
    if (SD)
      SD.push(0);
    return {
      data,
      facets: newFacets,
      channels: {
        ...newChannels,
        ...FD && { fill: { value: FD, scale: "color" } },
        ...SD && { stroke: { value: SD, scale: "color" } },
        contours: { value: contours }
      }
    };
  });
}
function isDensity(value) {
  return /^density$/i.test(value);
}

// node_modules/@observablehq/plot/dist/marks/frame.js
var defaults10 = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor"
};
var Frame = class extends Mark {
  constructor(options = {}) {
    const { inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;
    super(void 0, void 0, options, defaults10);
    this.insetTop = number3(insetTop);
    this.insetRight = number3(insetRight);
    this.insetBottom = number3(insetBottom);
    this.insetLeft = number3(insetLeft);
    this.rx = number3(rx);
    this.ry = number3(ry);
  }
  render(index, scales, channels, dimensions, context) {
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const { insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;
    return create2("svg:rect", context).call(applyIndirectStyles, this, scales, dimensions).call(applyDirectStyles, this).call(applyTransform, this, {}).attr("x", marginLeft + insetLeft).attr("y", marginTop + insetTop).attr("width", width - marginLeft - marginRight - insetLeft - insetRight).attr("height", height - marginTop - marginBottom - insetTop - insetBottom).attr("rx", rx).attr("ry", ry).node();
  }
};
function frame2(options) {
  return new Frame(options);
}

// node_modules/@observablehq/plot/dist/transforms/hexbin.js
var ox = 0.5;
var oy = 0;
function hexbin(outputs = { fill: "count" }, options = {}) {
  let { binWidth, ...remainingOptions } = options;
  binWidth = binWidth === void 0 ? 20 : number3(binWidth);
  outputs = maybeOutputs(outputs, remainingOptions);
  const { z, fill, stroke } = remainingOptions;
  if (stroke === void 0 && isNoneish(fill) && hasOutput(outputs, "fill"))
    remainingOptions.stroke = "none";
  if (remainingOptions.symbol === void 0)
    remainingOptions.symbol = "hexagon";
  if (remainingOptions.r === void 0 && !hasOutput(outputs, "r"))
    remainingOptions.r = binWidth / 2;
  return initializer(remainingOptions, (data, facets, { x: X3, y: Y3, z: Z, fill: F, stroke: S, symbol: Q }, scales) => {
    if (X3 === void 0)
      throw new Error("missing channel: x");
    if (Y3 === void 0)
      throw new Error("missing channel: y");
    X3 = coerceNumbers(valueof(X3.value, scales[X3.scale] || identity3));
    Y3 = coerceNumbers(valueof(Y3.value, scales[Y3.scale] || identity3));
    Z = Z ? Z.value : valueof(data, z);
    F = F?.value;
    S = S?.value;
    Q = Q?.value;
    const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S, symbol: Q });
    const GZ = Z && [];
    const GF = F && [];
    const GS = S && [];
    const GQ = Q && [];
    const binFacets = [];
    const BX = [];
    const BY = [];
    let i = -1;
    for (const o of outputs)
      o.initialize(data);
    for (const facet of facets) {
      const binFacet = [];
      for (const o of outputs)
        o.scope("facet", facet);
      for (const [f, I] of maybeGroup(facet, G)) {
        for (const bin3 of hbin(I, X3, Y3, binWidth)) {
          binFacet.push(++i);
          BX.push(bin3.x);
          BY.push(bin3.y);
          if (Z)
            GZ.push(G === Z ? f : Z[bin3[0]]);
          if (F)
            GF.push(G === F ? f : F[bin3[0]]);
          if (S)
            GS.push(G === S ? f : S[bin3[0]]);
          if (Q)
            GQ.push(G === Q ? f : Q[bin3[0]]);
          for (const o of outputs)
            o.reduce(bin3);
        }
      }
      binFacets.push(binFacet);
    }
    const channels = {
      x: { value: BX },
      y: { value: BY },
      ...Z && { z: { value: GZ } },
      ...F && { fill: { value: GF, scale: true } },
      ...S && { stroke: { value: GS, scale: true } },
      ...Q && { symbol: { value: GQ, scale: true } },
      ...Object.fromEntries(outputs.map(({ name, output }) => [
        name,
        { scale: true, radius: name === "r" ? binWidth / 2 : void 0, value: output.transform() }
      ]))
    };
    return { data, facets: binFacets, channels };
  });
}
function hbin(I, X3, Y3, dx) {
  const dy = dx * (1.5 / sqrt3);
  const bins = /* @__PURE__ */ new Map();
  for (const i of I) {
    let px = X3[i], py = Y3[i];
    if (isNaN(px) || isNaN(py))
      continue;
    let pj = Math.round(py = (py - oy) / dy), pi4 = Math.round(px = (px - ox) / dx - (pj & 1) / 2), py1 = py - pj;
    if (Math.abs(py1) * 3 > 1) {
      let px1 = px - pi4, pi22 = pi4 + (px < pi4 ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi22, py2 = py - pj2;
      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)
        pi4 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
    }
    const key = `${pi4},${pj}`;
    let bin3 = bins.get(key);
    if (bin3 === void 0) {
      bins.set(key, bin3 = []);
      bin3.x = (pi4 + (pj & 1) / 2) * dx + ox;
      bin3.y = pj * dy + oy;
    }
    bin3.push(i);
  }
  return bins.values();
}

// node_modules/@observablehq/plot/dist/marks/hexgrid.js
var defaults11 = {
  ariaLabel: "hexgrid",
  fill: "none",
  stroke: "currentColor",
  strokeOpacity: 0.1
};
function hexgrid(options) {
  return new Hexgrid(options);
}
var Hexgrid = class extends Mark {
  constructor({ binWidth = 20, clip = true, ...options } = {}) {
    super(void 0, void 0, { clip, ...options }, defaults11);
    this.binWidth = number3(binWidth);
  }
  render(index, scales, channels, dimensions, context) {
    const { binWidth } = this;
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const x05 = marginLeft - ox, x12 = width - marginRight - ox, y05 = marginTop - oy, y12 = height - marginBottom - oy;
    const rx = binWidth / 2, ry = rx * sqrt4_3, hy = ry / 2, wx = rx * 2, wy = ry * 1.5;
    const path = `m0,${-ry}l${rx},${hy}v${ry}l${-rx},${hy}`;
    const i0 = Math.floor(x05 / wx), i1 = Math.ceil(x12 / wx);
    const j0 = Math.floor((y05 + hy) / wy), j1 = Math.ceil((y12 - hy) / wy) + 1;
    const m = [];
    for (let j = j0; j < j1; ++j) {
      for (let i = i0; i < i1; ++i) {
        m.push(`M${i * wx + (j & 1) * rx},${j * wy}${path}`);
      }
    }
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call((g) => g.append("path").call(applyDirectStyles, this).call(applyTransform, this, {}, offset + ox, offset + oy).attr("d", m.join(""))).node();
  }
};

// node_modules/@observablehq/plot/dist/marks/image.js
var defaults12 = {
  ariaLabel: "image",
  fill: null,
  stroke: null
};
function isPath(string2) {
  return /^\.*\//.test(string2);
}
function isUrl(string2) {
  return /^(blob|data|file|http|https):/i.test(string2);
}
function maybePathChannel(value) {
  return typeof value === "string" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];
}
var Image2 = class extends Mark {
  constructor(data, options = {}) {
    let { x: x2, y: y2, width, height, src, preserveAspectRatio, crossOrigin, frameAnchor } = options;
    if (width === void 0 && height !== void 0)
      width = height;
    else if (height === void 0 && width !== void 0)
      height = width;
    const [vs, cs] = maybePathChannel(src);
    const [vw, cw] = maybeNumberChannel(width, 16);
    const [vh, ch] = maybeNumberChannel(height, 16);
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      width: { value: vw, filter: positive, optional: true },
      height: { value: vh, filter: positive, optional: true },
      src: { value: vs, optional: true }
    }, options, defaults12);
    this.src = cs;
    this.width = cw;
    this.height = ch;
    this.preserveAspectRatio = impliedString(preserveAspectRatio, "xMidYMid");
    this.crossOrigin = string(crossOrigin);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, width: W, height: H, src: S } = channels;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(index).enter().append("image").call(applyDirectStyles, this).attr("x", W && X3 ? (i) => X3[i] - W[i] / 2 : W ? (i) => cx - W[i] / 2 : X3 ? (i) => X3[i] - this.width / 2 : cx - this.width / 2).attr("y", H && Y3 ? (i) => Y3[i] - H[i] / 2 : H ? (i) => cy - H[i] / 2 : Y3 ? (i) => Y3[i] - this.height / 2 : cy - this.height / 2).attr("width", W ? (i) => W[i] : this.width).attr("height", H ? (i) => H[i] : this.height).call(applyAttr, "href", S ? (i) => S[i] : this.src).call(applyAttr, "preserveAspectRatio", this.preserveAspectRatio).call(applyAttr, "crossorigin", this.crossOrigin).call(applyChannelStyles, this, channels)).node();
  }
};
function image(data, options = {}) {
  let { x: x2, y: y2, ...remainingOptions } = options;
  if (options.frameAnchor === void 0)
    [x2, y2] = maybeTuple(x2, y2);
  return new Image2(data, { ...remainingOptions, x: x2, y: y2 });
}

// node_modules/@observablehq/plot/dist/marks/line.js
var defaults13 = {
  ariaLabel: "line",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Line = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y: y2, z, curve, tension } = options;
    super(data, {
      x: { value: x2, scale: "x" },
      y: { value: y2, scale: "y" },
      z: { value: maybeZ(options), optional: true }
    }, options, defaults13);
    this.z = z;
    this.curve = Curve(curve, tension);
    markers(this, options);
  }
  filter(index) {
    return index;
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3 } = channels;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(groupIndex(index, [X3, Y3], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels).attr("d", line_default().curve(this.curve).defined((i) => i >= 0).x((i) => X3[i]).y((i) => Y3[i]))).node();
  }
};
function line(data, options = {}) {
  let { x: x2, y: y2, ...remainingOptions } = options;
  [x2, y2] = maybeTuple(x2, y2);
  return new Line(data, { ...remainingOptions, x: x2, y: y2 });
}
function lineX(data, options = {}) {
  const { x: x2 = identity3, y: y2 = indexOf, ...remainingOptions } = options;
  return new Line(data, maybeDenseIntervalY({ ...remainingOptions, x: x2, y: y2 }));
}
function lineY(data, options = {}) {
  const { x: x2 = indexOf, y: y2 = identity3, ...remainingOptions } = options;
  return new Line(data, maybeDenseIntervalX({ ...remainingOptions, x: x2, y: y2 }));
}

// node_modules/@observablehq/plot/dist/stats.js
function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b12 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x2, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = p < 0.5 ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x2 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x2 = -x2;
    al = (x2 * x2 - 3) / 6;
    h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
    w = x2 * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));
    x2 = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x2 = Math.pow(a * w * p, 1 / a);
    else
      x2 = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -gammaln(a) - gammaln(b) + gammaln(a + b);
  for (; j < 10; j++) {
    if (x2 === 0 || x2 === 1)
      return x2;
    err = ibeta(x2, a, b) - p;
    t = Math.exp(a1 * Math.log(x2) + b12 * Math.log(1 - x2) + afac);
    u = err / t;
    x2 -= t = u / (1 - 0.5 * Math.min(1, u * (a1 / x2 - b12 / (1 - x2))));
    if (x2 <= 0)
      x2 = 0.5 * (x2 + t);
    if (x2 >= 1)
      x2 = 0.5 * (x2 + t + 1);
    if (Math.abs(t) < EPS * x2 && j > 0)
      break;
  }
  return x2;
}
function ibeta(x2, a, b) {
  var bt = x2 === 0 || x2 === 1 ? 0 : Math.exp(gammaln(a + b) - gammaln(a) - gammaln(b) + a * Math.log(x2) + b * Math.log(1 - x2));
  if (x2 < 0 || x2 > 1)
    return false;
  if (x2 < (a + 1) / (a + b + 2))
    return bt * betacf(x2, a, b) / a;
  return 1 - bt * betacf(1 - x2, b, a) / b;
}
function betacf(x2, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c3 = 1;
  var d = 1 - qab * x2 / qap;
  var m2, aa, del, h;
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;
  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x2 / ((qam + m2) * (a + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c3 = 1 + aa / c3;
    if (Math.abs(c3) < fpmin)
      c3 = fpmin;
    d = 1 / d;
    h *= d * c3;
    aa = -(a + m) * (qab + m) * x2 / ((a + m2) * (qap + m2));
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c3 = 1 + aa / c3;
    if (Math.abs(c3) < fpmin)
      c3 = fpmin;
    d = 1 / d;
    del = d * c3;
    h *= del;
    if (Math.abs(del - 1) < 3e-7)
      break;
  }
  return h;
}
function gammaln(x2) {
  var j = 0;
  var cof = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  var ser = 1.000000000190015;
  var xx, y2, tmp;
  tmp = (y2 = xx = x2) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y2;
  return Math.log(2.506628274631 * ser / xx) - tmp;
}
function qt(p, dof) {
  var x2 = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
  x2 = Math.sqrt(dof * (1 - x2) / x2);
  return p > 0.5 ? x2 : -x2;
}

// node_modules/@observablehq/plot/dist/marks/linearRegression.js
var defaults14 = {
  ariaLabel: "linear-regression",
  fill: "currentColor",
  fillOpacity: 0.1,
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var LinearRegression = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y: y2, z, ci = 0.95, precision = 4 } = options;
    super(data, {
      x: { value: x2, scale: "x" },
      y: { value: y2, scale: "y" },
      z: { value: maybeZ(options), optional: true }
    }, options, defaults14);
    this.z = z;
    this.ci = +ci;
    this.precision = +precision;
    if (!(0 <= this.ci && this.ci < 1))
      throw new Error(`invalid ci; not in [0, 1): ${ci}`);
    if (!(this.precision > 0))
      throw new Error(`invalid precision: ${precision}`);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, z: Z } = channels;
    const { ci } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(Z ? groupZ(index, Z, this.z) : [index]).enter().call((enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr("d", (I) => this._renderLine(I, X3, Y3)).call(ci && !isNone(this.fill) ? (path) => path.select(pathBefore).attr("stroke", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
      ...channels,
      stroke: null,
      strokeOpacity: null,
      strokeWidth: null
    }).attr("d", (I) => this._renderBand(I, X3, Y3)) : () => {
    }))).node();
  }
};
function pathBefore() {
  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, "path"), this);
}
var LinearRegressionX = class extends LinearRegression {
  constructor(data, options) {
    super(data, options);
  }
  _renderBand(I, X3, Y3) {
    const { ci, precision } = this;
    const [y12, y2] = extent(I, (i) => Y3[i]);
    const f = linearRegressionF(I, Y3, X3);
    const g = confidenceIntervalF(I, Y3, X3, (1 - ci) / 2, f);
    return area_default().y((y3) => y3).x0((y3) => g(y3, -1)).x1((y3) => g(y3, 1))(range(y12, y2 - precision / 2, precision).concat(y2));
  }
  _renderLine(I, X3, Y3) {
    const [y12, y2] = extent(I, (i) => Y3[i]);
    const f = linearRegressionF(I, Y3, X3);
    return `M${f(y12)},${y12}L${f(y2)},${y2}`;
  }
};
var LinearRegressionY = class extends LinearRegression {
  constructor(data, options) {
    super(data, options);
  }
  _renderBand(I, X3, Y3) {
    const { ci, precision } = this;
    const [x12, x2] = extent(I, (i) => X3[i]);
    const f = linearRegressionF(I, X3, Y3);
    const g = confidenceIntervalF(I, X3, Y3, (1 - ci) / 2, f);
    return area_default().x((x3) => x3).y0((x3) => g(x3, -1)).y1((x3) => g(x3, 1))(range(x12, x2 - precision / 2, precision).concat(x2));
  }
  _renderLine(I, X3, Y3) {
    const [x12, x2] = extent(I, (i) => X3[i]);
    const f = linearRegressionF(I, X3, Y3);
    return `M${x12},${f(x12)}L${x2},${f(x2)}`;
  }
};
function linearRegressionX(data, options = {}) {
  const { y: y2 = indexOf, x: x2 = identity3, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...remainingOptions } = options;
  return new LinearRegressionX(data, maybeDenseIntervalY({ ...remainingOptions, x: x2, y: y2, fill, stroke }));
}
function linearRegressionY(data, options = {}) {
  const { x: x2 = indexOf, y: y2 = identity3, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...remainingOptions } = options;
  return new LinearRegressionY(data, maybeDenseIntervalX({ ...remainingOptions, x: x2, y: y2, fill, stroke }));
}
function linearRegressionF(I, X3, Y3) {
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (const i of I) {
    const xi = X3[i];
    const yi = Y3[i];
    sumX += xi;
    sumY += yi;
    sumXY += xi * yi;
    sumX2 += xi * xi;
  }
  const n = I.length;
  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  return (x2) => slope * x2 + intercept;
}
function confidenceIntervalF(I, X3, Y3, p, f) {
  const mean2 = sum(I, (i) => X3[i]) / I.length;
  let a = 0, b = 0;
  for (const i of I) {
    a += (X3[i] - mean2) ** 2;
    b += (Y3[i] - f(X3[i])) ** 2;
  }
  const sy = Math.sqrt(b / (I.length - 2));
  const t = qt(p, I.length - 2);
  return (x2, k) => {
    const Y4 = f(x2);
    const se = sy * Math.sqrt(1 / I.length + (x2 - mean2) ** 2 / a);
    return Y4 + k * t * se;
  };
}

// node_modules/@observablehq/plot/dist/marks/rect.js
var defaults15 = {
  ariaLabel: "rect"
};
var Rect = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, y1: y12, x2, y2, inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;
    super(data, {
      x1: { value: x12, scale: "x", optional: true },
      y1: { value: y12, scale: "y", optional: true },
      x2: { value: x2, scale: "x", optional: true },
      y2: { value: y2, scale: "y", optional: true }
    }, options, defaults15);
    this.insetTop = number3(insetTop);
    this.insetRight = number3(insetRight);
    this.insetBottom = number3(insetBottom);
    this.insetLeft = number3(insetLeft);
    this.rx = impliedString(rx, "auto");
    this.ry = impliedString(ry, "auto");
  }
  render(index, scales, channels, dimensions, context) {
    const { x: x2, y: y2 } = scales;
    const { x1: X12, y1: Y12, x2: X22, y2: Y22 } = channels;
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const { insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, { x: X12 && X22 ? x2 : null, y: Y12 && Y22 ? y2 : null }, 0, 0).call((g) => g.selectAll().data(index).enter().append("rect").call(applyDirectStyles, this).attr("x", X12 && X22 && !isCollapsed(x2) ? (i) => Math.min(X12[i], X22[i]) + insetLeft : marginLeft + insetLeft).attr("y", Y12 && Y22 && !isCollapsed(y2) ? (i) => Math.min(Y12[i], Y22[i]) + insetTop : marginTop + insetTop).attr("width", X12 && X22 && !isCollapsed(x2) ? (i) => Math.max(0, Math.abs(X22[i] - X12[i]) - insetLeft - insetRight) : width - marginRight - marginLeft - insetRight - insetLeft).attr("height", Y12 && Y22 && !isCollapsed(y2) ? (i) => Math.max(0, Math.abs(Y12[i] - Y22[i]) - insetTop - insetBottom) : height - marginTop - marginBottom - insetTop - insetBottom).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)).node();
  }
};
function rect(data, options) {
  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));
}
function rectX(data, options = { y: indexOf, interval: 1, x2: identity3 }) {
  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));
}
function rectY(data, options = { x: indexOf, interval: 1, y2: identity3 }) {
  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));
}

// node_modules/@observablehq/plot/dist/marks/text.js
var defaults16 = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
};
var Text = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y: y2, text: text2 = isIterable(data) && isTextual(data) ? identity3 : indexOf, frameAnchor, textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle", lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle", lineHeight = 1, lineWidth = Infinity, monospace, fontFamily = monospace ? "ui-monospace, monospace" : void 0, fontSize, fontStyle, fontVariant, fontWeight, rotate } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      fontSize: { value: vfontSize, optional: true },
      rotate: { value: numberChannel(vrotate), optional: true },
      text: { value: text2, filter: nonempty }
    }, options, defaults16);
    this.rotate = crotate;
    this.textAnchor = impliedString(textAnchor, "middle");
    this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = cfontSize;
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, rotate: R, text: T, fontSize: FS } = channels;
    const { rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, scales, dimensions).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(index).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T).attr("transform", R ? X3 && Y3 ? (i) => `translate(${X3[i]},${Y3[i]}) rotate(${R[i]})` : X3 ? (i) => `translate(${X3[i]},${cy}) rotate(${R[i]})` : Y3 ? (i) => `translate(${cx},${Y3[i]}) rotate(${R[i]})` : (i) => `translate(${cx},${cy}) rotate(${R[i]})` : rotate ? X3 && Y3 ? (i) => `translate(${X3[i]},${Y3[i]}) rotate(${rotate})` : X3 ? (i) => `translate(${X3[i]},${cy}) rotate(${rotate})` : Y3 ? (i) => `translate(${cx},${Y3[i]}) rotate(${rotate})` : `translate(${cx},${cy}) rotate(${rotate})` : X3 && Y3 ? (i) => `translate(${X3[i]},${Y3[i]})` : X3 ? (i) => `translate(${X3[i]},${cy})` : Y3 ? (i) => `translate(${cx},${Y3[i]})` : `translate(${cx},${cy})`).call(applyAttr, "font-size", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)).node();
  }
};
function applyMultilineText(selection2, { monospace, lineAnchor, lineHeight, lineWidth }, T) {
  if (!T)
    return;
  const linesof = isFinite(lineWidth) ? monospace ? (t) => lineWrap(t, lineWidth, monospaceWidth) : (t) => lineWrap(t, lineWidth * 100, defaultWidth) : (t) => t.split(/\r\n?|\n/g);
  selection2.each(function(i) {
    const lines = linesof(formatDefault(T[i]));
    const n = lines.length;
    const y2 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n : (164 - n * 100) / 200;
    if (n > 1) {
      for (let i2 = 0; i2 < n; ++i2) {
        if (!lines[i2])
          continue;
        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
        tspan.setAttribute("x", 0);
        tspan.setAttribute("y", `${(y2 + i2) * lineHeight}em`);
        tspan.textContent = lines[i2];
        this.appendChild(tspan);
      }
    } else {
      if (y2)
        this.setAttribute("y", `${y2 * lineHeight}em`);
      this.textContent = lines[0];
    }
  });
}
function text(data, options = {}) {
  let { x: x2, y: y2, ...remainingOptions } = options;
  if (options.frameAnchor === void 0)
    [x2, y2] = maybeTuple(x2, y2);
  return new Text(data, { ...remainingOptions, x: x2, y: y2 });
}
function textX(data, options = {}) {
  const { x: x2 = identity3, ...remainingOptions } = options;
  return new Text(data, maybeIntervalMidY({ ...remainingOptions, x: x2 }));
}
function textY(data, options = {}) {
  const { y: y2 = identity3, ...remainingOptions } = options;
  return new Text(data, maybeIntervalMidX({ ...remainingOptions, y: y2 }));
}
function applyIndirectTextStyles(selection2, mark, T) {
  applyAttr(selection2, "text-anchor", mark.textAnchor);
  applyAttr(selection2, "font-family", mark.fontFamily);
  applyAttr(selection2, "font-size", mark.fontSize);
  applyAttr(selection2, "font-style", mark.fontStyle);
  applyAttr(selection2, "font-variant", mark.fontVariant === void 0 && (isNumeric(T) || isTemporal(T)) ? "tabular-nums" : mark.fontVariant);
  applyAttr(selection2, "font-weight", mark.fontWeight);
}
var fontSizes = /* @__PURE__ */ new Set([
  "inherit",
  "initial",
  "revert",
  "unset",
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  "larger",
  "smaller"
]);
function maybeFontSizeChannel(fontSize) {
  if (fontSize == null || typeof fontSize === "number")
    return [void 0, fontSize];
  if (typeof fontSize !== "string")
    return [fontSize, void 0];
  fontSize = fontSize.trim().toLowerCase();
  return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
}
function lineWrap(input, maxWidth, widthof = (_, i, j) => j - i) {
  const lines = [];
  let lineStart, lineEnd = 0;
  for (const [wordStart, wordEnd, required2] of lineBreaks(input)) {
    if (lineStart === void 0)
      lineStart = wordStart;
    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
      lines.push(input.slice(lineStart, lineEnd));
      lineStart = wordStart;
    }
    if (required2) {
      lines.push(input.slice(lineStart, wordEnd));
      lineStart = void 0;
      continue;
    }
    lineEnd = wordEnd;
  }
  return lines;
}
function* lineBreaks(input) {
  let i = 0, j = 0;
  const n = input.length;
  while (j < n) {
    let k = 1;
    switch (input[j]) {
      case "-":
        ++j;
        yield [i, j, false];
        i = j;
        break;
      case " ":
        yield [i, j, false];
        while (input[++j] === " ")
          ;
        i = j;
        break;
      case "\r":
        if (input[j + 1] === "\n")
          ++k;
      case "\n":
        yield [i, j, true];
        j += k;
        i = j;
        break;
      default:
        ++j;
        break;
    }
  }
  yield [i, j, true];
}
var defaultWidthMap = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "\u2018": 31,
  "\u2019": 31,
  "\u201C": 47,
  "\u201D": 47
};
function defaultWidth(text2, start2, end) {
  let sum2 = 0;
  for (let i = start2; i < end; ++i) {
    sum2 += defaultWidthMap[text2[i]] || defaultWidthMap.e;
    const first2 = text2.charCodeAt(i);
    if (first2 >= 55296 && first2 <= 56319) {
      const second2 = text2.charCodeAt(i + 1);
      if (second2 >= 56320 && second2 <= 57343) {
        ++i;
      }
    }
  }
  return sum2;
}
function monospaceWidth(text2, start2, end) {
  return end - start2;
}

// node_modules/@observablehq/plot/dist/transforms/tree.js
function treeNode(options = {}) {
  let {
    path = identity3,
    delimiter,
    frameAnchor,
    treeLayout = tree_default,
    treeSort,
    treeSeparation,
    treeAnchor,
    ...remainingOptions
  } = options;
  treeAnchor = maybeTreeAnchor(treeAnchor);
  treeSort = maybeTreeSort(treeSort);
  if (frameAnchor === void 0)
    frameAnchor = treeAnchor.frameAnchor;
  const normalize3 = normalizer(delimiter);
  const outputs = treeOutputs(remainingOptions, maybeNodeValue);
  const [X3, setX] = column();
  const [Y3, setY] = column();
  return {
    x: X3,
    y: Y3,
    frameAnchor,
    ...basic(remainingOptions, (data, facets) => {
      const P = normalize3(valueof(data, path));
      const X4 = setX([]);
      const Y4 = setY([]);
      let treeIndex = -1;
      const treeData = [];
      const treeFacets = [];
      const rootof = stratify_default().path((i) => P[i]);
      const layout = treeLayout();
      if (layout.nodeSize)
        layout.nodeSize([1, 1]);
      if (layout.separation && treeSeparation !== void 0)
        layout.separation(treeSeparation ?? one);
      for (const o of outputs)
        o[output_values] = o[output_setValues]([]);
      for (const facet of facets) {
        const treeFacet = [];
        const root2 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
        if (treeSort != null)
          root2.sort(treeSort);
        layout(root2);
        for (const node of root2.descendants()) {
          treeFacet.push(++treeIndex);
          treeData[treeIndex] = node.data;
          treeAnchor.position(node, treeIndex, X4, Y4);
          for (const o of outputs)
            o[output_values][treeIndex] = o[output_evaluate](node);
        }
        treeFacets.push(treeFacet);
      }
      return { data: treeData, facets: treeFacets };
    }),
    ...Object.fromEntries(outputs)
  };
}
function treeLink(options = {}) {
  let {
    path = identity3,
    delimiter,
    curve = "bump-x",
    stroke = "#555",
    strokeWidth = 1.5,
    strokeOpacity = 0.5,
    treeLayout = tree_default,
    treeSort,
    treeSeparation,
    treeAnchor,
    ...remainingOptions
  } = options;
  treeAnchor = maybeTreeAnchor(treeAnchor);
  treeSort = maybeTreeSort(treeSort);
  remainingOptions = { curve, stroke, strokeWidth, strokeOpacity, ...remainingOptions };
  const normalize3 = normalizer(delimiter);
  const outputs = treeOutputs(remainingOptions, maybeLinkValue);
  const [X12, setX1] = column();
  const [X22, setX2] = column();
  const [Y12, setY1] = column();
  const [Y22, setY2] = column();
  return {
    x1: X12,
    x2: X22,
    y1: Y12,
    y2: Y22,
    ...basic(remainingOptions, (data, facets) => {
      const P = normalize3(valueof(data, path));
      const X13 = setX1([]);
      const X23 = setX2([]);
      const Y13 = setY1([]);
      const Y23 = setY2([]);
      let treeIndex = -1;
      const treeData = [];
      const treeFacets = [];
      const rootof = stratify_default().path((i) => P[i]);
      const layout = treeLayout();
      if (layout.nodeSize)
        layout.nodeSize([1, 1]);
      if (layout.separation && treeSeparation !== void 0)
        layout.separation(treeSeparation ?? one);
      for (const o of outputs)
        o[output_values] = o[output_setValues]([]);
      for (const facet of facets) {
        const treeFacet = [];
        const root2 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);
        if (treeSort != null)
          root2.sort(treeSort);
        layout(root2);
        for (const { source, target } of root2.links()) {
          treeFacet.push(++treeIndex);
          treeData[treeIndex] = target.data;
          treeAnchor.position(source, treeIndex, X13, Y13);
          treeAnchor.position(target, treeIndex, X23, Y23);
          for (const o of outputs)
            o[output_values][treeIndex] = o[output_evaluate](target, source);
        }
        treeFacets.push(treeFacet);
      }
      return { data: treeData, facets: treeFacets };
    }),
    ...Object.fromEntries(outputs)
  };
}
function maybeTreeAnchor(anchor = "left") {
  switch (`${anchor}`.trim().toLowerCase()) {
    case "left":
      return treeAnchorLeft;
    case "right":
      return treeAnchorRight;
  }
  throw new Error(`invalid tree anchor: ${anchor}`);
}
var treeAnchorLeft = {
  frameAnchor: "left",
  dx: 6,
  position({ x: x2, y: y2 }, i, X3, Y3) {
    X3[i] = y2;
    Y3[i] = -x2;
  }
};
var treeAnchorRight = {
  frameAnchor: "right",
  dx: -6,
  position({ x: x2, y: y2 }, i, X3, Y3) {
    X3[i] = -y2;
    Y3[i] = -x2;
  }
};
function maybeTreeSort(sort3) {
  return sort3 == null || typeof sort3 === "function" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith("node:") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));
}
function nodeSort(value) {
  return (a, b) => ascendingDefined(value(a), value(b));
}
function nodeData(field2) {
  return (node) => node.data?.[field2];
}
function normalizer(delimiter = "/") {
  return `${delimiter}` === "/" ? (P) => P : (P) => P.map(replaceAll(delimiter, "/"));
}
function replaceAll(search, replace) {
  search = new RegExp(regexEscape(search), "g");
  return (value) => value == null ? null : `${value}`.replace(search, replace);
}
function regexEscape(string2) {
  return `${string2}`.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
function isNodeValue(option) {
  return isObject(option) && typeof option.node === "function";
}
function isLinkValue(option) {
  return isObject(option) && typeof option.link === "function";
}
function maybeNodeValue(value) {
  if (isNodeValue(value))
    return value.node;
  value = `${value}`.trim().toLowerCase();
  if (!value.startsWith("node:"))
    return;
  switch (value) {
    case "node:name":
      return nodeName;
    case "node:path":
      return nodePath;
    case "node:internal":
      return nodeInternal;
    case "node:depth":
      return nodeDepth;
    case "node:height":
      return nodeHeight;
  }
  throw new Error(`invalid node value: ${value}`);
}
function maybeLinkValue(value) {
  if (isNodeValue(value))
    return value.node;
  if (isLinkValue(value))
    return value.link;
  value = `${value}`.trim().toLowerCase();
  if (!value.startsWith("node:") && !value.startsWith("parent:"))
    return;
  switch (value) {
    case "parent:name":
      return parentValue(nodeName);
    case "parent:path":
      return parentValue(nodePath);
    case "parent:depth":
      return parentValue(nodeDepth);
    case "parent:height":
      return parentValue(nodeHeight);
    case "node:name":
      return nodeName;
    case "node:path":
      return nodePath;
    case "node:internal":
      return nodeInternal;
    case "node:depth":
      return nodeDepth;
    case "node:height":
      return nodeHeight;
  }
  throw new Error(`invalid link value: ${value}`);
}
function nodePath(node) {
  return node.id;
}
function nodeName(node) {
  return nameof(node.id);
}
function nodeDepth(node) {
  return node.depth;
}
function nodeHeight(node) {
  return node.height;
}
function nodeInternal(node) {
  return !!node.children;
}
function parentValue(evaluate) {
  return (child, parent) => parent == null ? void 0 : evaluate(parent);
}
function nameof(path) {
  let i = path.length;
  while (--i > 0)
    if (slash2(path, i))
      break;
  return path.slice(i + 1);
}
function slash2(path, i) {
  if (path[i] === "/") {
    let k = 0;
    while (i > 0 && path[--i] === "\\")
      ++k;
    if ((k & 1) === 0)
      return true;
  }
  return false;
}
var output_setValues = 2;
var output_evaluate = 3;
var output_values = 4;
function treeOutputs(options, maybeTreeValue) {
  const outputs = [];
  for (const name in options) {
    const value = options[name];
    const treeValue = maybeTreeValue(value);
    if (treeValue !== void 0) {
      outputs.push([name, ...column(value), treeValue]);
    }
  }
  return outputs;
}

// node_modules/@observablehq/plot/dist/marks/tree.js
function tree(data, options = {}) {
  let { fill, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, marker, markerStart = marker, markerEnd = marker, dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd), text: textText = "node:name", textStroke = "white", title = "node:path", dx, dy, ...remainingOptions } = options;
  if (dx === void 0)
    dx = maybeTreeAnchor(remainingOptions.treeAnchor).dx;
  return marks(link2(data, treeLink({
    markerStart,
    markerEnd,
    stroke: stroke !== void 0 ? stroke : fill === void 0 ? "node:internal" : fill,
    strokeWidth,
    strokeOpacity,
    strokeLinejoin,
    strokeLinecap,
    strokeMiterlimit,
    strokeDasharray,
    strokeDashoffset,
    ...remainingOptions
  })), dotDot ? dot(data, treeNode({ fill: fill === void 0 ? "node:internal" : fill, title, ...remainingOptions })) : null, textText != null ? text(data, treeNode({
    text: textText,
    fill: fill === void 0 ? "currentColor" : fill,
    stroke: textStroke,
    dx,
    dy,
    title,
    ...remainingOptions
  })) : null);
}
function cluster(data, options) {
  return tree(data, { ...options, treeLayout: cluster_default });
}

// node_modules/@observablehq/plot/dist/marks/vector.js
var defaults17 = {
  ariaLabel: "vector",
  fill: null,
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round"
};
var Vector = class extends Mark {
  constructor(data, options = {}) {
    const { x: x2, y: y2, length: length2, rotate, anchor = "middle", frameAnchor } = options;
    const [vl, cl] = maybeNumberChannel(length2, 12);
    const [vr, cr] = maybeNumberChannel(rotate, 0);
    super(data, {
      x: { value: x2, scale: "x", optional: true },
      y: { value: y2, scale: "y", optional: true },
      length: { value: vl, scale: "length", optional: true },
      rotate: { value: vr, optional: true }
    }, options, defaults17);
    this.length = cl;
    this.rotate = cr;
    this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, length: L, rotate: R } = channels;
    const { length: length2, rotate, anchor } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const fl = L ? (i) => L[i] : () => length2;
    const fr = R ? (i) => R[i] : () => rotate;
    const fx = X3 ? (i) => X3[i] : () => cx;
    const fy = Y3 ? (i) => Y3[i] : () => cy;
    const k = anchor === "start" ? 0 : anchor === "end" ? 1 : 0.5;
    return create2("svg:g", context).attr("fill", "none").call(applyIndirectStyles, this, scales, dimensions).call(applyTransform, this, scales).call((g) => g.selectAll().data(index).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => {
      const l = fl(i), a = fr(i) * radians2;
      const x2 = Math.sin(a) * l, y2 = -Math.cos(a) * l;
      const d = (x2 + y2) / 5, e = (x2 - y2) / 5;
      return `M${fx(i) - x2 * k},${fy(i) - y2 * k}l${x2},${y2}m${-e},${-d}l${e},${d}l${-d},${e}`;
    }).call(applyChannelStyles, this, channels)).node();
  }
};
function vector(data, options = {}) {
  let { x: x2, y: y2, ...remainingOptions } = options;
  if (options.frameAnchor === void 0)
    [x2, y2] = maybeTuple(x2, y2);
  return new Vector(data, { ...remainingOptions, x: x2, y: y2 });
}
function vectorX(data, options = {}) {
  const { x: x2 = identity3, ...remainingOptions } = options;
  return new Vector(data, { ...remainingOptions, x: x2 });
}
function vectorY(data, options = {}) {
  const { y: y2 = identity3, ...remainingOptions } = options;
  return new Vector(data, { ...remainingOptions, y: y2 });
}

// node_modules/@observablehq/plot/dist/transforms/dodge.js
var import_interval_tree_1d = __toESM(require_interval_tree(), 1);
var anchorXLeft = ({ marginLeft }) => [1, marginLeft];
var anchorXRight = ({ width, marginRight }) => [-1, width - marginRight];
var anchorXMiddle = ({ width, marginLeft, marginRight }) => [0, (marginLeft + width - marginRight) / 2];
var anchorYTop = ({ marginTop }) => [1, marginTop];
var anchorYBottom = ({ height, marginBottom }) => [-1, height - marginBottom];
var anchorYMiddle = ({ height, marginTop, marginBottom }) => [0, (marginTop + height - marginBottom) / 2];
function maybeAnchor(anchor) {
  return typeof anchor === "string" ? { anchor } : anchor;
}
function dodgeX(dodgeOptions = {}, options = {}) {
  if (arguments.length === 1)
    [dodgeOptions, options] = mergeOptions3(dodgeOptions);
  let { anchor = "left", padding = 1 } = maybeAnchor(dodgeOptions);
  switch (`${anchor}`.toLowerCase()) {
    case "left":
      anchor = anchorXLeft;
      break;
    case "right":
      anchor = anchorXRight;
      break;
    case "middle":
      anchor = anchorXMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("x", "y", anchor, number3(padding), options);
}
function dodgeY(dodgeOptions = {}, options = {}) {
  if (arguments.length === 1)
    [dodgeOptions, options] = mergeOptions3(dodgeOptions);
  let { anchor = "bottom", padding = 1 } = maybeAnchor(dodgeOptions);
  switch (`${anchor}`.toLowerCase()) {
    case "top":
      anchor = anchorYTop;
      break;
    case "bottom":
      anchor = anchorYBottom;
      break;
    case "middle":
      anchor = anchorYMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("y", "x", anchor, number3(padding), options);
}
function mergeOptions3(options) {
  const { anchor, padding, ...rest } = options;
  return [{ anchor, padding }, rest];
}
function dodge(y2, x2, anchor, padding, options) {
  const { r } = options;
  if (r != null && typeof r !== "number") {
    const { channels, sort: sort3, reverse: reverse3 } = options;
    options = { ...options, channels: { r: { value: r, scale: "r" }, ...maybeNamed(channels) } };
    if (sort3 === void 0 && reverse3 === void 0)
      options.sort = { channel: "r", order: "descending" };
  }
  return initializer(options, function(data, facets, { [x2]: X3, r: R }, scales, dimensions) {
    if (!X3)
      throw new Error(`missing channel: ${x2}`);
    X3 = coerceNumbers(valueof(X3.value, scales[X3.scale] || identity3));
    const r2 = R ? void 0 : this.r !== void 0 ? this.r : options.r !== void 0 ? number3(options.r) : 3;
    if (R)
      R = coerceNumbers(valueof(R.value, scales[R.scale] || identity3));
    let [ky, ty] = anchor(dimensions);
    const compare = ky ? compareAscending : compareSymmetric;
    const Y3 = new Float64Array(X3.length);
    const radius2 = R ? (i) => R[i] : () => r2;
    for (let I of facets) {
      const tree2 = (0, import_interval_tree_1d.default)();
      I = I.filter(R ? (i) => finite(X3[i]) && positive(R[i]) : (i) => finite(X3[i]));
      const intervals = new Float64Array(2 * I.length + 2);
      for (const i of I) {
        const ri = radius2(i);
        const y05 = ky ? ri + padding : 0;
        const l = X3[i] - ri;
        const h = X3[i] + ri;
        let k = 2;
        tree2.queryInterval(l - padding, h + padding, ([, , j]) => {
          const yj = Y3[j] - y05;
          const dx = X3[i] - X3[j];
          const dr = padding + (R ? R[i] + R[j] : 2 * r2);
          const dy = Math.sqrt(dr * dr - dx * dx);
          intervals[k++] = yj - dy;
          intervals[k++] = yj + dy;
        });
        let candidates = intervals.slice(0, k);
        if (ky)
          candidates = candidates.filter((y3) => y3 >= 0);
        out:
          for (const y3 of candidates.sort(compare)) {
            for (let j = 0; j < k; j += 2) {
              if (intervals[j] + 1e-6 < y3 && y3 < intervals[j + 1] - 1e-6) {
                continue out;
              }
            }
            Y3[i] = y3 + y05;
            break;
          }
        tree2.insert([l, h, i]);
      }
    }
    if (!ky)
      ky = 1;
    for (const I of facets) {
      for (const i of I) {
        Y3[i] = Y3[i] * ky + ty;
      }
    }
    return {
      data,
      facets,
      channels: {
        [x2]: { value: X3 },
        [y2]: { value: Y3 },
        ...R && { r: { value: R } }
      }
    };
  });
}
function compareSymmetric(a, b) {
  return Math.abs(a) - Math.abs(b);
}
function compareAscending(a, b) {
  return a - b;
}

// node_modules/@observablehq/plot/dist/transforms/normalize.js
function normalizeX(basis, options) {
  if (arguments.length === 1)
    ({ basis, ...options } = basis);
  return mapX(normalize2(basis), options);
}
function normalizeY(basis, options) {
  if (arguments.length === 1)
    ({ basis, ...options } = basis);
  return mapY(normalize2(basis), options);
}
function normalize2(basis) {
  if (basis === void 0)
    return normalizeFirst;
  if (typeof basis === "function")
    return normalizeBasis((I, S) => basis(take(S, I)));
  if (/^p\d{2}$/i.test(basis))
    return normalizeAccessor(percentile(basis));
  switch (`${basis}`.toLowerCase()) {
    case "deviation":
      return normalizeDeviation;
    case "first":
      return normalizeFirst;
    case "last":
      return normalizeLast;
    case "max":
      return normalizeMax;
    case "mean":
      return normalizeMean;
    case "median":
      return normalizeMedian;
    case "min":
      return normalizeMin;
    case "sum":
      return normalizeSum;
    case "extent":
      return normalizeExtent;
  }
  throw new Error(`invalid basis: ${basis}`);
}
function normalizeBasis(basis) {
  return {
    map(I, S, T) {
      const b = +basis(I, S);
      for (const i of I) {
        T[i] = S[i] === null ? NaN : S[i] / b;
      }
    }
  };
}
function normalizeAccessor(f) {
  return normalizeBasis((I, S) => f(I, (i) => S[i]));
}
var normalizeExtent = {
  map(I, S, T) {
    const [s1, s2] = extent(I, (i) => S[i]), d = s2 - s1;
    for (const i of I) {
      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;
    }
  }
};
var normalizeFirst = normalizeBasis((I, S) => {
  for (let i = 0; i < I.length; ++i) {
    const s = S[I[i]];
    if (defined(s))
      return s;
  }
});
var normalizeLast = normalizeBasis((I, S) => {
  for (let i = I.length - 1; i >= 0; --i) {
    const s = S[I[i]];
    if (defined(s))
      return s;
  }
});
var normalizeDeviation = {
  map(I, S, T) {
    const m = mean(I, (i) => S[i]);
    const d = deviation(I, (i) => S[i]);
    for (const i of I) {
      T[i] = S[i] === null ? NaN : d ? (S[i] - m) / d : 0;
    }
  }
};
var normalizeMax = normalizeAccessor(max);
var normalizeMean = normalizeAccessor(mean);
var normalizeMedian = normalizeAccessor(median);
var normalizeMin = normalizeAccessor(min);
var normalizeSum = normalizeAccessor(sum);

// node_modules/@observablehq/plot/dist/transforms/window.js
function windowX(windowOptions = {}, options) {
  if (arguments.length === 1)
    options = windowOptions;
  return mapX(window2(windowOptions), options);
}
function windowY(windowOptions = {}, options) {
  if (arguments.length === 1)
    options = windowOptions;
  return mapY(window2(windowOptions), options);
}
function window2(options = {}) {
  if (typeof options === "number")
    options = { k: options };
  let { k, reduce, shift, anchor, strict } = options;
  if (anchor === void 0 && shift !== void 0) {
    anchor = maybeShift(shift);
    warn(`Warning: the shift option is deprecated; please use anchor "${anchor}" instead.`);
  }
  if (!((k = Math.floor(k)) > 0))
    throw new Error(`invalid k: ${k}`);
  return maybeReduce2(reduce)(k, maybeAnchor2(anchor, k), strict);
}
function maybeAnchor2(anchor = "middle", k) {
  switch (`${anchor}`.toLowerCase()) {
    case "middle":
      return k - 1 >> 1;
    case "start":
      return 0;
    case "end":
      return k - 1;
  }
  throw new Error(`invalid anchor: ${anchor}`);
}
function maybeShift(shift) {
  switch (`${shift}`.toLowerCase()) {
    case "centered":
      return "middle";
    case "leading":
      return "start";
    case "trailing":
      return "end";
  }
  throw new Error(`invalid shift: ${shift}`);
}
function maybeReduce2(reduce = "mean") {
  if (typeof reduce === "string") {
    if (/^p\d{2}$/i.test(reduce))
      return reduceNumbers(percentile(reduce));
    switch (reduce.toLowerCase()) {
      case "deviation":
        return reduceNumbers(deviation);
      case "max":
        return reduceArray(max);
      case "mean":
        return reduceMean;
      case "median":
        return reduceNumbers(median);
      case "min":
        return reduceArray(min);
      case "mode":
        return reduceArray(mode);
      case "sum":
        return reduceSum2;
      case "variance":
        return reduceNumbers(variance);
      case "difference":
        return reduceDifference;
      case "ratio":
        return reduceRatio;
      case "first":
        return reduceFirst2;
      case "last":
        return reduceLast2;
    }
  }
  if (typeof reduce !== "function")
    throw new Error(`invalid reduce: ${reduce}`);
  return reduceArray(reduce);
}
function slice4(I, i, j) {
  return I.subarray ? I.subarray(i, j) : I.slice(i, j);
}
function reduceNumbers(f) {
  return (k, s, strict) => strict ? {
    map(I, S, T) {
      const C = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
      let nans = 0;
      for (let i = 0; i < k - 1; ++i)
        if (isNaN(C[i]))
          ++nans;
      for (let i = 0, n = I.length - k + 1; i < n; ++i) {
        if (isNaN(C[i + k - 1]))
          ++nans;
        T[I[i + s]] = nans === 0 ? f(C.subarray(i, i + k)) : NaN;
        if (isNaN(C[i]))
          --nans;
      }
    }
  } : {
    map(I, S, T) {
      const C = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);
      for (let i = -s; i < 0; ++i) {
        T[I[i + s]] = f(C.subarray(0, i + k));
      }
      for (let i = 0, n = I.length - s; i < n; ++i) {
        T[I[i + s]] = f(C.subarray(i, i + k));
      }
    }
  };
}
function reduceArray(f) {
  return (k, s, strict) => strict ? {
    map(I, S, T) {
      let count3 = 0;
      for (let i = 0; i < k - 1; ++i)
        count3 += defined(S[I[i]]);
      for (let i = 0, n = I.length - k + 1; i < n; ++i) {
        count3 += defined(S[I[i + k - 1]]);
        if (count3 === k)
          T[I[i + s]] = f(take(S, slice4(I, i, i + k)));
        count3 -= defined(S[I[i]]);
      }
    }
  } : {
    map(I, S, T) {
      for (let i = -s; i < 0; ++i) {
        T[I[i + s]] = f(take(S, slice4(I, 0, i + k)));
      }
      for (let i = 0, n = I.length - s; i < n; ++i) {
        T[I[i + s]] = f(take(S, slice4(I, i, i + k)));
      }
    }
  };
}
function reduceSum2(k, s, strict) {
  return strict ? {
    map(I, S, T) {
      let nans = 0;
      let sum2 = 0;
      for (let i = 0; i < k - 1; ++i) {
        const v = S[I[i]];
        if (v === null || isNaN(v))
          ++nans;
        else
          sum2 += +v;
      }
      for (let i = 0, n = I.length - k + 1; i < n; ++i) {
        const a = S[I[i]];
        const b = S[I[i + k - 1]];
        if (b === null || isNaN(b))
          ++nans;
        else
          sum2 += +b;
        T[I[i + s]] = nans === 0 ? sum2 : NaN;
        if (a === null || isNaN(a))
          --nans;
        else
          sum2 -= +a;
      }
    }
  } : {
    map(I, S, T) {
      let sum2 = 0;
      const n = I.length;
      for (let i = 0, j = Math.min(n, k - s - 1); i < j; ++i) {
        sum2 += +S[I[i]] || 0;
      }
      for (let i = -s, j = n - s; i < j; ++i) {
        sum2 += +S[I[i + k - 1]] || 0;
        T[I[i + s]] = sum2;
        sum2 -= +S[I[i]] || 0;
      }
    }
  };
}
function reduceMean(k, s, strict) {
  if (strict) {
    const sum2 = reduceSum2(k, s, strict);
    return {
      map(I, S, T) {
        sum2.map(I, S, T);
        for (let i = 0, n = I.length - k + 1; i < n; ++i) {
          T[I[i + s]] /= k;
        }
      }
    };
  } else {
    return {
      map(I, S, T) {
        let sum2 = 0;
        let count3 = 0;
        const n = I.length;
        for (let i = 0, j = Math.min(n, k - s - 1); i < j; ++i) {
          let v = S[I[i]];
          if (v !== null && !isNaN(v = +v))
            sum2 += v, ++count3;
        }
        for (let i = -s, j = n - s; i < j; ++i) {
          let a = S[I[i + k - 1]];
          let b = S[I[i]];
          if (a !== null && !isNaN(a = +a))
            sum2 += a, ++count3;
          T[I[i + s]] = sum2 / count3;
          if (b !== null && !isNaN(b = +b))
            sum2 -= b, --count3;
        }
      }
    };
  }
}
function firstDefined(S, I, i, k) {
  for (let j = i + k; i < j; ++i) {
    const v = S[I[i]];
    if (defined(v))
      return v;
  }
}
function lastDefined(S, I, i, k) {
  for (let j = i + k - 1; j >= i; --j) {
    const v = S[I[j]];
    if (defined(v))
      return v;
  }
}
function firstNumber(S, I, i, k) {
  for (let j = i + k; i < j; ++i) {
    let v = S[I[i]];
    if (v !== null && !isNaN(v = +v))
      return v;
  }
}
function lastNumber(S, I, i, k) {
  for (let j = i + k - 1; j >= i; --j) {
    let v = S[I[j]];
    if (v !== null && !isNaN(v = +v))
      return v;
  }
}
function reduceDifference(k, s, strict) {
  return strict ? {
    map(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        const a = S[I[i]];
        const b = S[I[i + k - 1]];
        T[I[i + s]] = a === null || b === null ? NaN : b - a;
      }
    }
  } : {
    map(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = lastNumber(S, I, i, k) - firstNumber(S, I, i, k);
      }
    }
  };
}
function reduceRatio(k, s, strict) {
  return strict ? {
    map(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        const a = S[I[i]];
        const b = S[I[i + k - 1]];
        T[I[i + s]] = a === null || b === null ? NaN : b / a;
      }
    }
  } : {
    map(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = lastNumber(S, I, i, k) / firstNumber(S, I, i, k);
      }
    }
  };
}
function reduceFirst2(k, s, strict) {
  return strict ? {
    map(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        T[I[i + s]] = S[I[i]];
      }
    }
  } : {
    map(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = firstDefined(S, I, i, k);
      }
    }
  };
}
function reduceLast2(k, s, strict) {
  return strict ? {
    map(I, S, T) {
      for (let i = 0, n = I.length - k; i < n; ++i) {
        T[I[i + s]] = S[I[i + k - 1]];
      }
    }
  } : {
    map(I, S, T) {
      for (let i = -s, n = I.length - k + s + 1; i < n; ++i) {
        T[I[i + s]] = lastDefined(S, I, i, k);
      }
    }
  };
}

// node_modules/@observablehq/plot/dist/transforms/select.js
function select(selector, options = {}) {
  if (typeof selector === "string") {
    switch (selector.toLowerCase()) {
      case "first":
        return selectFirst(options);
      case "last":
        return selectLast(options);
    }
  }
  if (typeof selector === "function") {
    return selectChannel(null, selector, options);
  }
  let key, value;
  for (key in selector) {
    if (value !== void 0)
      throw new Error("ambiguous selector; multiple inputs");
    value = maybeSelector(selector[key]);
  }
  if (value === void 0)
    throw new Error(`invalid selector: ${selector}`);
  return selectChannel(key, value, options);
}
function maybeSelector(selector) {
  if (typeof selector === "function")
    return selector;
  switch (`${selector}`.toLowerCase()) {
    case "min":
      return selectorMin;
    case "max":
      return selectorMax;
  }
  throw new Error(`unknown selector: ${selector}`);
}
function selectFirst(options) {
  return selectChannel(null, selectorFirst, options);
}
function selectLast(options) {
  return selectChannel(null, selectorLast, options);
}
function selectMinX(options) {
  return selectChannel("x", selectorMin, options);
}
function selectMinY(options) {
  return selectChannel("y", selectorMin, options);
}
function selectMaxX(options) {
  return selectChannel("x", selectorMax, options);
}
function selectMaxY(options) {
  return selectChannel("y", selectorMax, options);
}
function* selectorFirst(I) {
  yield I[0];
}
function* selectorLast(I) {
  yield I[I.length - 1];
}
function* selectorMin(I, X3) {
  yield least(I, (i) => X3[i]);
}
function* selectorMax(I, X3) {
  yield greatest(I, (i) => X3[i]);
}
function selectChannel(v, selector, options) {
  if (v != null) {
    if (options[v] == null)
      throw new Error(`missing channel: ${v}`);
    v = options[v];
  }
  const z = maybeZ(options);
  return basic(options, (data, facets) => {
    const Z = valueof(data, z);
    const V = valueof(data, v);
    const selectFacets = [];
    for (const facet of facets) {
      const selectFacet = [];
      for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {
        for (const i of selector(I, V)) {
          selectFacet.push(i);
        }
      }
      selectFacets.push(selectFacet);
    }
    return { data, facets: selectFacets };
  });
}
export {
  Area,
  Arrow,
  BarX,
  BarY,
  Cell,
  Density,
  Dot,
  Frame,
  Hexgrid,
  Image2 as Image,
  Line,
  Link,
  Mark,
  Rect,
  RuleX,
  RuleY,
  Text,
  TickX,
  TickY,
  Vector,
  area,
  areaX,
  areaY,
  arrow,
  barX,
  barY,
  bin2 as bin,
  binX,
  binY,
  boxX,
  boxY,
  cell,
  cellX,
  cellY,
  circle2 as circle,
  cluster,
  column,
  delaunayLink,
  delaunayMesh,
  density,
  dodgeX,
  dodgeY,
  dot,
  dotX,
  dotY,
  filter2 as filter,
  formatIsoDate,
  formatMonth,
  formatWeekday,
  frame2 as frame,
  group2 as group,
  groupX,
  groupY,
  groupZ2 as groupZ,
  hexagon,
  hexbin,
  hexgrid,
  hull,
  image,
  initializer,
  legend,
  line,
  lineX,
  lineY,
  linearRegressionX,
  linearRegressionY,
  link2 as link,
  map2 as map,
  mapX,
  mapY,
  marks,
  normalize2 as normalize,
  normalizeX,
  normalizeY,
  plot,
  rect,
  rectX,
  rectY,
  reverse2 as reverse,
  ruleX,
  ruleY,
  scale,
  select,
  selectFirst,
  selectLast,
  selectMaxX,
  selectMaxY,
  selectMinX,
  selectMinY,
  shuffle2 as shuffle,
  sort2 as sort,
  stackX,
  stackX1,
  stackX2,
  stackY,
  stackY1,
  stackY2,
  text,
  textX,
  textY,
  tickX,
  tickY,
  basic as transform,
  tree,
  treeLink,
  treeNode,
  valueof,
  vector,
  vectorX,
  vectorY,
  voronoi,
  voronoiMesh,
  window2 as window,
  windowX,
  windowY
};
//# sourceMappingURL=@observablehq_plot.js.map
